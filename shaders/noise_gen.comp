#version 430 core

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(rgba32f, binding = 0) uniform image3D noiseTexture;
layout(rgba32f, binding = 1) uniform image3D curlTexture;
layout(rgba32f, binding = 2) uniform image3D cloudBaseTexture;
layout(rgba32f, binding = 3) uniform image3D cloudDetailTexture;
layout(rgba32f, binding = 4) uniform image2D weatherMap;

#include "helpers/noise.glsl"

// Helper to compute curl noise using finite differences
vec3 computeCurl(vec3 p) {
	float e = 0.01;
	vec3  dx = vec3(e, 0.0, 0.0);
	vec3  dy = vec3(0.0, e, 0.0);
	vec3  dz = vec3(0.0, 0.0, e);

	// Offsets to decorrelate the potential field components
	vec3 o1 = vec3(123.4, 567.8, 910.1);
	vec3 o2 = vec3(234.5, 678.9, 112.2);
	vec3 o3 = vec3(345.6, 789.0, 223.3);

	// Potential components derivatives
	float dPsi_z_dy = (snoise3d(p + dy + o3) - snoise3d(p - dy + o3)) / (2.0 * e);
	float dPsi_y_dz = (snoise3d(p + dz + o2) - snoise3d(p - dz + o2)) / (2.0 * e);

	float dPsi_x_dz = (snoise3d(p + dz + o1) - snoise3d(p - dz + o1)) / (2.0 * e);
	float dPsi_z_dx = (snoise3d(p + dx + o3) - snoise3d(p - dx + o3)) / (2.0 * e);

	float dPsi_y_dx = (snoise3d(p + dx + o2) - snoise3d(p - dx + o2)) / (2.0 * e);
	float dPsi_x_dy = (snoise3d(p + dy + o1) - snoise3d(p - dy + o1)) / (2.0 * e);

	return vec3(dPsi_z_dy - dPsi_y_dz, dPsi_x_dz - dPsi_z_dx, dPsi_y_dx - dPsi_x_dy);
}

vec3 computeFbmCurl(vec3 p, int octaves) {
	vec3  total = vec3(0.0);
	float amp = 1.0;
	float freq = 1.0;
	for (int i = 0; i < octaves; i++) {
		total += computeCurl(p * freq) * amp;
		amp *= 0.5;
		freq *= 2.0;
	}
	return total;
}

// 3D Worley/Cellular noise - Tiled
float worley3d_tiled(vec3 p, float tile) {
	vec3  i = floor(p);
	vec3  f = fract(p);
	float minDist = 1.0;
	for (int z = -1; z <= 1; z++) {
		for (int y = -1; y <= 1; y++) {
			for (int x = -1; x <= 1; x++) {
				vec3 neighbor = vec3(float(x), float(y), float(z));
				vec3 point = hash33(mod(i + neighbor, tile));
				vec3 diff = neighbor + point - f;
				minDist = min(minDist, dot(diff, diff));
			}
		}
	}
	return sqrt(minDist);
}

// Tiled Perlin Noise
float perlin3d_tiled(vec3 p, float tile) {
    vec3 i = floor(p);
    vec3 f = fract(p);

    vec3 w = f * f * (3.0 - 2.0 * f);

    float a = dot(hash33(mod(i + vec3(0,0,0), tile)) - 0.5, f - vec3(0,0,0));
    float b = dot(hash33(mod(i + vec3(1,0,0), tile)) - 0.5, f - vec3(1,0,0));
    float c = dot(hash33(mod(i + vec3(0,1,0), tile)) - 0.5, f - vec3(0,1,0));
    float d = dot(hash33(mod(i + vec3(1,1,0), tile)) - 0.5, f - vec3(1,1,0));
    float e = dot(hash33(mod(i + vec3(0,0,1), tile)) - 0.5, f - vec3(0,0,1));
    float g = dot(hash33(mod(i + vec3(1,0,1), tile)) - 0.5, f - vec3(1,0,1));
    float h = dot(hash33(mod(i + vec3(0,1,1), tile)) - 0.5, f - vec3(0,1,1));
    float j = dot(hash33(mod(i + vec3(1,1,1), tile)) - 0.5, f - vec3(1,1,1));

    return mix(mix(mix(a, b, w.x), mix(c, d, w.x), w.y),
               mix(mix(e, g, w.x), mix(h, j, w.x), w.y), w.z) * 0.5 + 0.5;
}

float remap(float value, float low1, float high1, float low2, float high2) {
    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);
}

void main() {
	ivec3 texelCoord = ivec3(gl_GlobalInvocationID.xyz);

    // 1. Original Noise & Curl Generation (64^3)
    ivec3 noiseSize = imageSize(noiseTexture);
	if (all(lessThan(texelCoord, noiseSize))) {
        vec3 p = vec3(texelCoord) / vec3(noiseSize);
        vec3 p_scaled = p * 8.0;

        float n_simplex = snoise3d(p_scaled) * 0.5 + 0.5;
        float n_worley = 1.0 - worley3d_tiled(p_scaled, 8.0);

        float n_fbm = 0.0;
        float amplitude = 0.5;
        vec3 p_fbm = p_scaled;
        for (int i = 0; i < 4; i++) {
            n_fbm += amplitude * snoise3d(p_fbm);
            p_fbm *= 2.0;
            amplitude *= 0.5;
        }
        n_fbm = n_fbm * 0.5 + 0.5;

        vec3 warp = vec3(
            snoise3d(p_scaled + vec3(0.0)),
            snoise3d(p_scaled + vec3(1.2, 3.4, 5.6)),
            snoise3d(p_scaled + vec3(5.6, 1.2, 3.4))
        );
        float n_warped = snoise3d(p_scaled + warp * 2.0) * 0.5 + 0.5;

        imageStore(noiseTexture, texelCoord, vec4(n_simplex, n_worley, n_fbm, n_warped));

        vec3 curl = computeCurl(p_scaled);
        float fbmCurl = length(computeFbmCurl(p_scaled, 3));
        imageStore(curlTexture, texelCoord, vec4(curl, fbmCurl));
    }

    // 2. Cloud Base Noise (128^3 recommended)
    ivec3 baseSize = imageSize(cloudBaseTexture);
    if (all(lessThan(texelCoord, baseSize))) {
        vec3 p = vec3(texelCoord) / vec3(baseSize);

        // Perlin-Worley
        float p0 = perlin3d_tiled(p * 4.0, 4.0);
        float w0 = 1.0 - worley3d_tiled(p * 4.0, 4.0);
        float pw = remap(p0, w0, 1.0, 0.0, 1.0);

        float w1 = 1.0 - worley3d_tiled(p * 8.0, 8.0);
        float w2 = 1.0 - worley3d_tiled(p * 16.0, 16.0);
        float w3 = 1.0 - worley3d_tiled(p * 32.0, 32.0);

        imageStore(cloudBaseTexture, texelCoord, vec4(pw, w1, w2, w3));
    }

    // 3. Cloud Detail Noise (32^3 recommended)
    ivec3 detailSize = imageSize(cloudDetailTexture);
    if (all(lessThan(texelCoord, detailSize))) {
        vec3 p = vec3(texelCoord) / vec3(detailSize);

        float w0 = 1.0 - worley3d_tiled(p * 4.0, 4.0);
        float w1 = 1.0 - worley3d_tiled(p * 8.0, 8.0);
        float w2 = 1.0 - worley3d_tiled(p * 16.0, 16.0);

        imageStore(cloudDetailTexture, texelCoord, vec4(w0, w1, w2, 0.0));
    }

    // 4. Weather Map (2D)
    ivec2 weatherSize = imageSize(weatherMap);
    if (all(lessThan(texelCoord.xy, weatherSize)) && texelCoord.z == 0) {
        vec2 uv = vec2(texelCoord.xy) / vec2(weatherSize);

        // Generate interesting weather patterns
        float coverage = snoise(uv * 4.0) * 0.5 + 0.5;
        float precipitation = snoise(uv * 8.0 + 10.0) * 0.5 + 0.5;
        float type = snoise(uv * 2.0 + 20.0) * 0.5 + 0.5;

        imageStore(weatherMap, texelCoord.xy, vec4(coverage, precipitation, type, 1.0));
    }
}
