#version 430 core

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(rgba32f, binding = 0) uniform image3D noiseTexture;
layout(rgba32f, binding = 1) uniform image3D curlTexture;

#include "helpers/noise.glsl"

// Helper to compute curl noise using finite differences
vec3 computeCurl(vec3 p) {
	float e = 0.01;
	vec3  dx = vec3(e, 0.0, 0.0);
	vec3  dy = vec3(0.0, e, 0.0);
	vec3  dz = vec3(0.0, 0.0, e);

	// Offsets to decorrelate the potential field components
	vec3 o1 = vec3(123.4, 567.8, 910.1);
	vec3 o2 = vec3(234.5, 678.9, 112.2);
	vec3 o3 = vec3(345.6, 789.0, 223.3);

	// Potential components derivatives
	float dPsi_z_dy = (snoise3d(p + dy + o3) - snoise3d(p - dy + o3)) / (2.0 * e);
	float dPsi_y_dz = (snoise3d(p + dz + o2) - snoise3d(p - dz + o2)) / (2.0 * e);

	float dPsi_x_dz = (snoise3d(p + dz + o1) - snoise3d(p - dz + o1)) / (2.0 * e);
	float dPsi_z_dx = (snoise3d(p + dx + o3) - snoise3d(p - dx + o3)) / (2.0 * e);

	float dPsi_y_dx = (snoise3d(p + dx + o2) - snoise3d(p - dx + o2)) / (2.0 * e);
	float dPsi_x_dy = (snoise3d(p + dy + o1) - snoise3d(p - dy + o1)) / (2.0 * e);

	return vec3(
		dPsi_z_dy - dPsi_y_dz,
		dPsi_x_dz - dPsi_z_dx,
		dPsi_y_dx - dPsi_x_dy
	);
}

vec3 computeFbmCurl(vec3 p, int octaves) {
	vec3  total = vec3(0.0);
	float amp = 1.0;
	float freq = 1.0;
	for (int i = 0; i < octaves; i++) {
		total += computeCurl(p * freq) * amp;
		amp *= 0.5;
		freq *= 2.0;
	}
	return total;
}

// 3D Simplex noise wrapper
float simplex3d(vec3 p) {
	return snoise3d(p);
}

// 3D Worley/Cellular noise
float worley3d(vec3 p) {
	vec3  i = floor(p);
	vec3  f = fract(p);
	float minDist = 1.0;
	for (int z = -1; z <= 1; z++) {
		for (int y = -1; y <= 1; y++) {
			for (int x = -1; x <= 1; x++) {
				vec3 neighbor = vec3(float(x), float(y), float(z));
				vec3 point = hash33(i + neighbor);
				vec3 diff = neighbor + point - f;
				minDist = min(minDist, dot(diff, diff));
			}
		}
	}
	return sqrt(minDist);
}

// 3D FBM Simplex
float fbm3d(vec3 p) {
	float value = 0.0;
	float amplitude = 0.5;
	for (int i = 0; i < 4; i++) {
		value += amplitude * snoise3d(p);
		p *= 2.0;
		amplitude *= 0.5;
	}
	return value;
}

void main() {
	ivec3 texelCoord = ivec3(gl_GlobalInvocationID.xyz);
	ivec3 size = imageSize(noiseTexture);

	if (any(greaterThanEqual(texelCoord, size))) {
		return;
	}

	vec3 p = vec3(texelCoord) / vec3(size);

	// Scale for interesting frequencies
	vec3 p_scaled = p * 8.0;

	float n_simplex = simplex3d(p_scaled) * 0.5 + 0.5;
	float n_worley = 1.0 - worley3d(p_scaled);
	float n_fbm = fbm3d(p_scaled) * 0.5 + 0.5;

	// Warped FBM
	vec3 warp = vec3(
		fbm3d(p_scaled + vec3(0.0, 0.0, 0.0)),
		fbm3d(p_scaled + vec3(1.2, 3.4, 5.6)),
		fbm3d(p_scaled + vec3(5.6, 1.2, 3.4))
	);
	float n_warped = fbm3d(p_scaled + warp * 2.0) * 0.5 + 0.5;

	imageStore(noiseTexture, texelCoord, vec4(n_simplex, n_worley, n_fbm, n_warped));

	// Generate Curl Noise
	vec3  curl = computeCurl(p_scaled);
	float fbmCurl = length(computeFbmCurl(p_scaled, 3));

	// Store Curl RGB and a variant (FBM curl magnitude) in Alpha
	imageStore(curlTexture, texelCoord, vec4(curl, fbmCurl));
}
