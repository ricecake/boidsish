#version 420 core

layout(vertices = 4) out;

in vec3 WorldPos_VS_out[];
in vec2 TexCoords_VS_out[];
in vec3 Normal_VS_out[];
in vec3 viewForward[];

out vec3 WorldPos_TC_out[];
out vec2 TexCoords_TC_out[];
out vec3 Normal_TC_out[];

#include "helpers/lighting.glsl"

uniform float uTessLevelMax = 64.0;
uniform float uTessLevelMin = 1.0;
uniform float uTessQualityMultiplier = 1.0;

float GetVertexTessLevel(vec3 worldPos, vec3 normal, vec3 forward) {
	// 1. DISTANCE FACTOR (The Base)
	float dist = distance(viewPos, worldPos);
	float distanceLevel = uTessLevelMax * exp(-dist * 0.02);
	distanceLevel = clamp(distanceLevel, uTessLevelMin, uTessLevelMax);

	// 2. SILHOUETTE FACTOR (The Boost)
	vec3  viewDir = normalize(viewPos - worldPos);
	float dotProd = dot(normalize(normal), viewDir);
	// 0.0 = Facing Camera, 1.0 = Silhouette
	float isSilhouette = 1.0 - abs(dotProd);

	// "Bump" logic:
	// If facing camera, use 1.0x the DistanceLevel.
	// If silhouette, use 3.0x the DistanceLevel (up to Max).
	// This ensures flat ground is still smooth, but edges are SUPER smooth.
	float silhouetteBoost = mix(1.0, 2.0, isSilhouette * (1 - dist / 500.0));

	// 3. FOCUS FACTOR (The Cull)
	// Vector from Camera -> Vertex
	vec3 dirCamToVertex = normalize(worldPos - viewPos);
	// Dot of CameraLook and VertexDir. 1.0 = Center Screen.
	float align = dot(dirCamToVertex, forward);

	// Drop detail rapidly if it's not in front of the camera
	// If align < 0.7 (approx 45 degrees), detail drops to 0
	float focusCull = smoothstep(0.85, 1.0, align);

	// COMBINE
	// We multiply the Base Distance Level by the Silhouette Boost
	float finalLevel = distanceLevel * silhouetteBoost;

	// Then we fade out things that are out of focus/off-screen
	finalLevel *= focusCull;
	finalLevel *= uTessQualityMultiplier;

	// Ensure we never drop below 1 (which would delete the mesh)
	// unless we are culling completely.
	return step(0, finalLevel) * max(finalLevel, uTessLevelMin);
}

void main() {
	WorldPos_TC_out[gl_InvocationID] = WorldPos_VS_out[gl_InvocationID];
	TexCoords_TC_out[gl_InvocationID] = TexCoords_VS_out[gl_InvocationID];
	Normal_TC_out[gl_InvocationID] = Normal_VS_out[gl_InvocationID];

	if (gl_InvocationID == 0) {
		// --- Curvature-based Tessellation ---
		// Get the normals of the four corners of the quad patch
		vec3 n0 = normalize(Normal_VS_out[0]);
		vec3 n1 = normalize(Normal_VS_out[1]);
		vec3 n2 = normalize(Normal_VS_out[2]);
		vec3 n3 = normalize(Normal_VS_out[3]);

		// Calculate the dot product between normals of adjacent vertices.
		// A value close to 1.0 means the normals are aligned (flat surface).
		// A value closer to 0.0 means they are perpendicular (sharp curve).
		float dot01 = abs(dot(n0, n1));
		float dot12 = abs(dot(n1, n2));
		float dot23 = abs(dot(n2, n3));
		float dot30 = abs(dot(n3, n0));

		// Average the alignment of the edges.
		float avgDot = (dot01 + dot12 + dot23 + dot30) * 0.25;

		// Create a factor that is high for curved surfaces and low for flat ones.
		// `smoothstep` creates a nice falloff.
		// If the average dot product is > 0.99 (very flat), the factor will be 0.1 (low tess).
		// If it's < 0.95 (curved), the factor will be 1.0 (full tess).
		float curvatureFactor = 1.0 - smoothstep(0.95, 0.99, avgDot) * 0.9;

		float l0 = GetVertexTessLevel(WorldPos_VS_out[0], Normal_VS_out[0], viewForward[0]);
		float l1 = GetVertexTessLevel(WorldPos_VS_out[1], Normal_VS_out[1], viewForward[1]);
		float l2 = GetVertexTessLevel(WorldPos_VS_out[2], Normal_VS_out[2], viewForward[2]);
		float l3 = GetVertexTessLevel(WorldPos_VS_out[3], Normal_VS_out[3], viewForward[3]);

		float edge0 = (l0 + l1) * 0.5 * curvatureFactor;
		float edge1 = (l1 + l2) * 0.5 * curvatureFactor;
		float edge2 = (l2 + l3) * 0.5 * curvatureFactor;
		float edge3 = (l3 + l0) * 0.5 * curvatureFactor;

		gl_TessLevelOuter[0] = clamp(edge0, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[1] = clamp(edge1, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[2] = clamp(edge2, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[3] = clamp(edge3, uTessLevelMin, uTessLevelMax);

		gl_TessLevelInner[0] = max(gl_TessLevelOuter[0], gl_TessLevelOuter[2]);
		gl_TessLevelInner[1] = max(gl_TessLevelOuter[1], gl_TessLevelOuter[3]);
	}
}