#version 420 core

layout(vertices = 4) out;

// Input from Vertex Shader
in vec3       LocalPos_VS_out[];
in vec2       TexCoords_VS_out[];
in vec3       viewForward[];
flat in float TextureSlice_VS_out[];
flat in vec3  WorldOffset_VS_out[];

// Output to Tessellation Evaluation Shader
out vec3       LocalPos_TC_out[];
out vec2       TexCoords_TC_out[];
flat out float TextureSlice_TC_out[];
flat out vec3  WorldOffset_TC_out[];
out float      perturbFactor_TC_out[];
out float      tessFactor_TC_out[];

// Heightmap texture array: R=height, GBA=normal
uniform sampler2DArray uHeightmap;
uniform int            uChunkSize;

#include "helpers/lighting.glsl"

uniform float uTessLevelMax = 32.0;
uniform float uTessLevelMin = 1.0;
uniform float uTessQualityMultiplier = 1.0;
uniform bool  uIsShadowPass = false;

// Sample heightmap to get world position and normal
void sampleHeightmap(vec2 uv, float slice, vec3 worldOffset, out vec3 worldPos, out vec3 normal) {
	vec4  data = texture(uHeightmap, vec3(uv, slice));
	float height = data.r;
	normal = normalize(data.gba);

	// Compute world position: local XZ from UV, Y from heightmap
	worldPos.x = worldOffset.x + uv.x * float(uChunkSize);
	worldPos.y = height;
	worldPos.z = worldOffset.z + uv.y * float(uChunkSize);
}

float GetVertexTessLevel(vec3 worldPos, vec3 normal, vec3 nextNormal, vec3 forward) {
	float dist = distance(viewPos, worldPos);
	vec3  viewDir = normalize(viewPos - worldPos);
	float dotProd = dot(normalize(normal), viewDir);
	float isSilhouette = 1.0 - abs(dotProd);

	if (uIsShadowPass) {
		return mix(16.0, 32.0, isSilhouette * smoothstep(800*worldScale, 200*worldScale, dist));
	}

	// 1. DISTANCE FACTOR (The Base)
	float distanceLevel = uTessLevelMax * exp(-dist * (0.005 / worldScale));
	distanceLevel = clamp(distanceLevel, uTessLevelMin, uTessLevelMax);

	// 2. SILHOUETTE FACTOR (The Boost)
	float silhouetteBoost = mix(1.0, 32.0, isSilhouette * smoothstep(800*worldScale, 200*worldScale, dist));


	// 3. FOCUS FACTOR (The Cull)
	vec3  dirCamToVertex = normalize(worldPos - viewPos);
	float align = dot(dirCamToVertex, forward);
	// Focus culling threshold - wider when world is larger to avoid edges
	float focusThreshold = mix(0.85, 0.65, clamp(worldScale / 10.0, 0.0, 1.0));
	float focusCull = mix(1.0, smoothstep(focusThreshold, 1.0, align), smoothstep(50, 100, dist));

	// COMBINE
	float finalLevel = distanceLevel * silhouetteBoost;
	finalLevel *= focusCull;
	finalLevel *= uTessQualityMultiplier;
	finalLevel *= mix(8.0, 1.0, smoothstep(-1, 1, dot(normal, nextNormal)));

	return step(0.0, finalLevel) * max(finalLevel, mix(16, 1, smoothstep(0, 5, worldPos.y)) * uTessLevelMin);
}

float perturbLevel(vec3 worldPos, vec3 forward) {
	if (uIsShadowPass) {
		return 0;
	}

	// 1. DISTANCE FACTOR (The Base)
	float dist = distance(viewPos, worldPos);
	float distanceLevel = uTessLevelMax * exp(-dist * (0.005 / worldScale));
	distanceLevel = clamp(distanceLevel, uTessLevelMin, uTessLevelMax);

	// 2. FOCUS FACTOR (The Cull)
	vec3  dirCamToVertex = normalize(worldPos - viewPos);
	float align = dot(dirCamToVertex, forward);
	float focusThreshold = mix(0.65, 0.45, clamp(worldScale / 10.0, 0.0, 1.0));
	float focusCull = mix(0.60, smoothstep(focusThreshold, 1.0, align), smoothstep(100, 250, dist));

	// 3. Y factor lock
	float distanceMin = 20 * worldScale * smoothstep(10 * worldScale, 0, abs(worldPos.y - viewPos.y));

	// COMBINE
	float finalLevel = max(distanceMin, distanceLevel) * focusCull;

	return clamp(0, 1, finalLevel / uTessLevelMax);
}

void main() {
	// Pass through local position and UVs
	LocalPos_TC_out[gl_InvocationID] = LocalPos_VS_out[gl_InvocationID];
	TexCoords_TC_out[gl_InvocationID] = TexCoords_VS_out[gl_InvocationID];
	TextureSlice_TC_out[gl_InvocationID] = TextureSlice_VS_out[gl_InvocationID];
	WorldOffset_TC_out[gl_InvocationID] = WorldOffset_VS_out[gl_InvocationID];

	vec3  preWorldPos0, preWorldPos1;
	vec3  preNormal0, preNormal1;
	float slice = TextureSlice_VS_out[0];
	vec3  worldOffset = WorldOffset_VS_out[0];

	sampleHeightmap(TexCoords_VS_out[(gl_InvocationID+1)%4], slice, worldOffset, preWorldPos0, preNormal0);
	sampleHeightmap(TexCoords_VS_out[(gl_InvocationID+1)%4], slice, worldOffset, preWorldPos1, preNormal1);

	perturbFactor_TC_out[gl_InvocationID] = perturbLevel(preWorldPos0, viewForward[gl_InvocationID]);
	tessFactor_TC_out[gl_InvocationID] = GetVertexTessLevel(preWorldPos0, preNormal0, preNormal1, viewForward[0]);

	if (gl_InvocationID == 0) {
		// Sample heightmap for all 4 corners to get world positions and normals

		vec3 worldPos0, worldPos1, worldPos2, worldPos3;
		vec3 normal0, normal1, normal2, normal3;

		sampleHeightmap(TexCoords_VS_out[0], slice, worldOffset, worldPos0, normal0);
		sampleHeightmap(TexCoords_VS_out[1], slice, worldOffset, worldPos1, normal1);
		sampleHeightmap(TexCoords_VS_out[2], slice, worldOffset, worldPos2, normal2);
		sampleHeightmap(TexCoords_VS_out[3], slice, worldOffset, worldPos3, normal3);

		// --- Curvature-based Tessellation ---
		float dot01 = abs(dot(normal0, normal1));
		float dot12 = abs(dot(normal1, normal2));
		float dot23 = abs(dot(normal2, normal3));
		float dot30 = abs(dot(normal3, normal0));

		// Create curvature factors per-edge to ensure consistency between adjacent patches.
		float curv01 = 1.0 + (1.0 - smoothstep(0.95, 0.99, dot01)) * 2.0;
		float curv12 = 1.0 + (1.0 - smoothstep(0.95, 0.99, dot12)) * 2.0;
		float curv23 = 1.0 + (1.0 - smoothstep(0.95, 0.99, dot23)) * 2.0;
		float curv30 = 1.0 + (1.0 - smoothstep(0.95, 0.99, dot30)) * 2.0;

		float l0 = GetVertexTessLevel(worldPos0, normal0, normal1, viewForward[0]);
		float l1 = GetVertexTessLevel(worldPos1, normal1, normal2, viewForward[1]);
		float l2 = GetVertexTessLevel(worldPos2, normal2, normal3, viewForward[2]);
		float l3 = GetVertexTessLevel(worldPos3, normal3, normal0, viewForward[3]);

		// Correct Mapping for Quads:
		// gl_TessLevelOuter[0] -> u=0 (edge 3-0)
		// gl_TessLevelOuter[1] -> v=0 (edge 0-1)
		// gl_TessLevelOuter[2] -> u=1 (edge 1-2)
		// gl_TessLevelOuter[3] -> v=1 (edge 2-3)
		gl_TessLevelOuter[0] = clamp((l3 + l0) * 0.5 * curv30, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[1] = clamp((l0 + l1) * 0.5 * curv01, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[2] = clamp((l1 + l2) * 0.5 * curv12, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[3] = clamp((l2 + l3) * 0.5 * curv23, uTessLevelMin, uTessLevelMax);

		gl_TessLevelInner[0] = max(gl_TessLevelOuter[0], gl_TessLevelOuter[2]);
		gl_TessLevelInner[1] = max(gl_TessLevelOuter[1], gl_TessLevelOuter[3]);
	}
}
