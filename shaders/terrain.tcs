#version 420 core

layout(vertices = 4) out;

// Input from Vertex Shader
in vec3       LocalPos_VS_out[];
in vec2       TexCoords_VS_out[];
in vec3       viewForward[];
flat in float TextureSlice_VS_out[];
flat in vec3  WorldOffset_VS_out[];

// Output to Tessellation Evaluation Shader
out vec3       LocalPos_TC_out[];
out vec2       TexCoords_TC_out[];
flat out float TextureSlice_TC_out[];
flat out vec3  WorldOffset_TC_out[];
out float      perturbFactor_TC_out[];
out float      tessFactor_TC_out[];

// Heightmap texture array: R=height, GBA=normal
uniform sampler2DArray uHeightmap;
uniform int            uChunkSize;

#include "helpers/lighting.glsl"

uniform float uTessLevelMax = 32.0;
uniform float uTessLevelMin = 1.0;
uniform float uTessQualityMultiplier = 1.0;
uniform bool  uIsShadowPass = false;

uniform mat4 view;
uniform mat4 projection;
uniform vec2 uViewportSize;

// Sample heightmap to get world position and normal
void sampleHeightmap(vec2 uv, float slice, vec3 worldOffset, out vec3 worldPos, out vec3 normal) {
	vec4  data = texture(uHeightmap, vec3(uv, slice));
	float height = data.r;
	normal = normalize(data.gba);

	// Compute world position: local XZ from UV, Y from heightmap
	worldPos.x = worldOffset.x + uv.x * float(uChunkSize);
	worldPos.y = height;
	worldPos.z = worldOffset.z + uv.y * float(uChunkSize);
}

float GetEdgeTessLevel(vec3 p0, vec3 p1, vec3 n0, vec3 n1) {
	// Project to clip space
	vec4 clip0 = projection * view * vec4(p0, 1.0);
	vec4 clip1 = projection * view * vec4(p1, 1.0);

	// Guard against points behind camera
	if (clip0.w <= 0.0 && clip1.w <= 0.0)
		return uTessLevelMin;

	// Perspective divide to get NDC
	vec2 ndc0 = clip0.xy / max(clip0.w, 0.01);
	vec2 ndc1 = clip1.xy / max(clip1.w, 0.01);

	// Convert to pixel coordinates
	vec2 pixel0 = (ndc0 * 0.5 + 0.5) * uViewportSize;
	vec2 pixel1 = (ndc1 * 0.5 + 0.5) * uViewportSize;

	// Edge length in pixels
	float pixelLength = length(pixel1 - pixel0);

	// Base tessellation: target pixels per segment
	// Target ~8 pixels per triangle edge for high quality, 16 for medium, 32 for low
	float targetPixels = 8.0 / uTessQualityMultiplier;
	float baseLevel = pixelLength / targetPixels;

	// 1. SILHOUETTE BOOST
	// Boost tessellation for edges that form the silhouette to keep curves smooth
	vec3  midPos = (p0 + p1) * 0.5;
	vec3  midNormal = normalize(n0 + n1);
	vec3  viewDir = normalize(viewPos - midPos);
	float silhouetteFactor = 1.0 - abs(dot(midNormal, viewDir));

	// Distance fade for silhouette boost to avoid over-tessellating distant silhouettes
	float dist = distance(viewPos, midPos);
	float silhouetteBoost = mix(1.0, 4.0, silhouetteFactor * smoothstep(1000.0 * worldScale, 200.0 * worldScale, dist));

	// 2. CURVATURE BOOST
	// Boost tessellation where surface normal changes rapidly
	float curvatureFactor = 1.0 - dot(n0, n1);
	float curvatureBoost = mix(1.0, 4.0, clamp(curvatureFactor * 10.0, 0.0, 1.0));

	float finalLevel = baseLevel * silhouetteBoost * curvatureBoost;

	return clamp(finalLevel, uTessLevelMin, uTessLevelMax);
}

float perturbLevel(vec3 worldPos, vec3 forward) {
	if (uIsShadowPass) {
		return 0;
	}

	// 1. DISTANCE FACTOR (The Base)
	float dist = distance(viewPos, worldPos);
	float distanceLevel = uTessLevelMax * exp(-dist * (0.005 / worldScale));
	distanceLevel = clamp(distanceLevel, uTessLevelMin, uTessLevelMax);

	// 2. FOCUS FACTOR (The Cull)
	vec3  dirCamToVertex = normalize(worldPos - viewPos);
	float align = dot(dirCamToVertex, forward);
	float focusThreshold = mix(0.65, 0.45, clamp(worldScale / 10.0, 0.0, 1.0));
	float focusCull = mix(0.60, smoothstep(focusThreshold, 1.0, align), smoothstep(100, 250, dist));

	// 3. Y factor lock
	float distanceMin = 20 * worldScale * smoothstep(10 * worldScale, 0, abs(worldPos.y - viewPos.y));

	// COMBINE
	float finalLevel = max(distanceMin, distanceLevel) * focusCull;

	return clamp(0, 1, finalLevel / uTessLevelMax);
}

void main() {
	// Pass through local position and UVs
	LocalPos_TC_out[gl_InvocationID] = LocalPos_VS_out[gl_InvocationID];
	TexCoords_TC_out[gl_InvocationID] = TexCoords_VS_out[gl_InvocationID];
	TextureSlice_TC_out[gl_InvocationID] = TextureSlice_VS_out[gl_InvocationID];
	WorldOffset_TC_out[gl_InvocationID] = WorldOffset_VS_out[gl_InvocationID];

	float slice = TextureSlice_VS_out[0];
	vec3  worldOffset = WorldOffset_VS_out[0];

	// Sample heightmap for this vertex
	vec3 pos, norm;
	sampleHeightmap(TexCoords_VS_out[gl_InvocationID], slice, worldOffset, pos, norm);

	// Calculate a representative tessellation factor for the vertex (used for shading effects)
	// We use a small offset to estimate local screen-space size
	float vTess = GetEdgeTessLevel(pos, pos + vec3(float(uChunkSize) * 0.03, 0, 0), norm, norm);
	tessFactor_TC_out[gl_InvocationID] = vTess;
	// perturbFactor_TC_out[gl_InvocationID] = clamp(vTess / uTessLevelMax, 0.0, 1.0);
	perturbFactor_TC_out[gl_InvocationID] = perturbLevel(pos, viewForward[gl_InvocationID]);

	if (gl_InvocationID == 0) {
		// Sample heightmap for all 4 corners to get world positions and normals
		vec3 worldPos0, worldPos1, worldPos2, worldPos3;
		vec3 normal0, normal1, normal2, normal3;

		sampleHeightmap(TexCoords_VS_out[0], slice, worldOffset, worldPos0, normal0);
		sampleHeightmap(TexCoords_VS_out[1], slice, worldOffset, worldPos1, normal1);
		sampleHeightmap(TexCoords_VS_out[2], slice, worldOffset, worldPos2, normal2);
		sampleHeightmap(TexCoords_VS_out[3], slice, worldOffset, worldPos3, normal3);

		// Project each edge to screen space and determine tessellation level
		// Correct Mapping for Quads:
		// gl_TessLevelOuter[0] -> u=0 (edge 3-0)
		// gl_TessLevelOuter[1] -> v=0 (edge 0-1)
		// gl_TessLevelOuter[2] -> u=1 (edge 1-2)
		// gl_TessLevelOuter[3] -> v=1 (edge 2-3)
		gl_TessLevelOuter[0] = GetEdgeTessLevel(worldPos3, worldPos0, normal3, normal0);
		gl_TessLevelOuter[1] = GetEdgeTessLevel(worldPos0, worldPos1, normal0, normal1);
		gl_TessLevelOuter[2] = GetEdgeTessLevel(worldPos1, worldPos2, normal1, normal2);
		gl_TessLevelOuter[3] = GetEdgeTessLevel(worldPos2, worldPos3, normal2, normal3);

		gl_TessLevelInner[0] = max(gl_TessLevelOuter[1], gl_TessLevelOuter[3]);
		gl_TessLevelInner[1] = max(gl_TessLevelOuter[0], gl_TessLevelOuter[2]);
	}
}
