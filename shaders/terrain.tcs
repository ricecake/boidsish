#version 420 core

layout(vertices = 4) out;

// Input from Vertex Shader
in vec3 LocalPos_VS_out[];
in vec2 TexCoords_VS_out[];
in vec3 viewForward[];
flat in float TextureSlice_VS_out[];
flat in vec3 WorldOffset_VS_out[];

// Output to Tessellation Evaluation Shader
out vec3 LocalPos_TC_out[];
out vec2 TexCoords_TC_out[];
flat out float TextureSlice_TC_out[];
flat out vec3 WorldOffset_TC_out[];

// Heightmap texture array: R=height, GBA=normal
uniform sampler2DArray uHeightmap;
uniform int uChunkSize;

#include "helpers/lighting.glsl"

uniform float uTessLevelMax = 64.0;
uniform float uTessLevelMin = 1.0;
uniform float uTessQualityMultiplier = 1.0;
uniform bool  uIsShadowPass = false;

// Sample heightmap to get world position and normal
void sampleHeightmap(vec2 uv, float slice, vec3 worldOffset, out vec3 worldPos, out vec3 normal) {
    vec4 data = texture(uHeightmap, vec3(uv, slice));
    float height = data.r;
    normal = normalize(data.gba);

    // Compute world position: local XZ from UV, Y from heightmap
    worldPos.x = worldOffset.x + uv.x * float(uChunkSize);
    worldPos.y = height;
    worldPos.z = worldOffset.z + uv.y * float(uChunkSize);
}

float GetVertexTessLevel(vec3 worldPos, vec3 normal, vec3 forward) {
    // 1. DISTANCE FACTOR (The Base)
    float dist = distance(viewPos, worldPos);
    float distanceLevel = uTessLevelMax * exp(-dist * 0.02);
    distanceLevel = clamp(distanceLevel, uTessLevelMin, uTessLevelMax);

    // 2. SILHOUETTE FACTOR (The Boost)
    vec3  viewDir = normalize(viewPos - worldPos);
    float dotProd = dot(normalize(normal), viewDir);
    float isSilhouette = 1.0 - abs(dotProd);
    float silhouetteBoost = mix(1.0, 2.0, isSilhouette * (1.0 - clamp(dist / 500.0, 0.0, 1.0)));

    // 3. FOCUS FACTOR (The Cull)
    float focusCull = 1.0;
    if (!uIsShadowPass) {
        vec3  dirCamToVertex = normalize(worldPos - viewPos);
        float align = dot(dirCamToVertex, forward);
        focusCull = smoothstep(0.85, 1.0, align);
    }

    // COMBINE
    float finalLevel = distanceLevel * silhouetteBoost;
    finalLevel *= focusCull;
    finalLevel *= uTessQualityMultiplier;

    // For shadow pass, ensure a minimum level to prevent light leaking
    float minLevel = uIsShadowPass ? max(uTessLevelMin, 8.0) : uTessLevelMin;

    return step(0.0, finalLevel) * max(finalLevel, minLevel);
}

void main() {
    // Pass through local position and UVs
    LocalPos_TC_out[gl_InvocationID] = LocalPos_VS_out[gl_InvocationID];
    TexCoords_TC_out[gl_InvocationID] = TexCoords_VS_out[gl_InvocationID];
    TextureSlice_TC_out[gl_InvocationID] = TextureSlice_VS_out[gl_InvocationID];
    WorldOffset_TC_out[gl_InvocationID] = WorldOffset_VS_out[gl_InvocationID];

    if (gl_InvocationID == 0) {
        // Sample heightmap for all 4 corners to get world positions and normals
        float slice = TextureSlice_VS_out[0];
        vec3 worldOffset = WorldOffset_VS_out[0];

        vec3 worldPos0, worldPos1, worldPos2, worldPos3;
        vec3 normal0, normal1, normal2, normal3;

        sampleHeightmap(TexCoords_VS_out[0], slice, worldOffset, worldPos0, normal0);
        sampleHeightmap(TexCoords_VS_out[1], slice, worldOffset, worldPos1, normal1);
        sampleHeightmap(TexCoords_VS_out[2], slice, worldOffset, worldPos2, normal2);
        sampleHeightmap(TexCoords_VS_out[3], slice, worldOffset, worldPos3, normal3);

        // --- Curvature-based Tessellation ---
        float dot01 = abs(dot(normal0, normal1));
        float dot12 = abs(dot(normal1, normal2));
        float dot23 = abs(dot(normal2, normal3));
        float dot30 = abs(dot(normal3, normal0));

		// Create curvature factors per-edge to ensure consistency between adjacent patches.
		float curv01 = 1.0 + (1.0 - smoothstep(0.95, 0.99, dot01)) * 2.0;
		float curv12 = 1.0 + (1.0 - smoothstep(0.95, 0.99, dot12)) * 2.0;
		float curv23 = 1.0 + (1.0 - smoothstep(0.95, 0.99, dot23)) * 2.0;
		float curv30 = 1.0 + (1.0 - smoothstep(0.95, 0.99, dot30)) * 2.0;

        float l0 = GetVertexTessLevel(worldPos0, normal0, viewForward[0]);
        float l1 = GetVertexTessLevel(worldPos1, normal1, viewForward[1]);
        float l2 = GetVertexTessLevel(worldPos2, normal2, viewForward[2]);
        float l3 = GetVertexTessLevel(worldPos3, normal3, viewForward[3]);

		// Correct Mapping for Quads:
		// gl_TessLevelOuter[0] -> u=0 (edge 3-0)
		// gl_TessLevelOuter[1] -> v=0 (edge 0-1)
		// gl_TessLevelOuter[2] -> u=1 (edge 1-2)
		// gl_TessLevelOuter[3] -> v=1 (edge 2-3)
		gl_TessLevelOuter[0] = clamp((l3 + l0) * 0.5 * curv30, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[1] = clamp((l0 + l1) * 0.5 * curv01, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[2] = clamp((l1 + l2) * 0.5 * curv12, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[3] = clamp((l2 + l3) * 0.5 * curv23, uTessLevelMin, uTessLevelMax);

		gl_TessLevelInner[0] = max(gl_TessLevelOuter[0], gl_TessLevelOuter[2]);
		gl_TessLevelInner[1] = max(gl_TessLevelOuter[1], gl_TessLevelOuter[3]);
	}
}
