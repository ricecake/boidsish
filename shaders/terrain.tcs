#version 420 core

layout(vertices = 4) out;

// Input from Vertex Shader
in vec3 LocalPos_VS_out[];
in vec2 TexCoords_VS_out[];
in vec3 viewForward[];
flat in float TextureSlice_VS_out[];
flat in vec3 WorldOffset_VS_out[];

// Output to Tessellation Evaluation Shader
out vec3 LocalPos_TC_out[];
out vec2 TexCoords_TC_out[];
flat out float TextureSlice_TC_out[];
flat out vec3 WorldOffset_TC_out[];

// Heightmap texture array: R=height, GBA=normal
uniform sampler2DArray uHeightmap;
uniform int uChunkSize;

#include "helpers/lighting.glsl"

uniform float uTessLevelMax = 64.0;
uniform float uTessLevelMin = 1.0;
uniform float uTessQualityMultiplier = 1.0;
uniform bool  uIsShadowPass = false;

// Sample heightmap to get world position and normal
void sampleHeightmap(vec2 uv, float slice, vec3 worldOffset, out vec3 worldPos, out vec3 normal) {
    vec4 data = texture(uHeightmap, vec3(uv, slice));
    float height = data.r;
    normal = normalize(data.gba);

    // Compute world position: local XZ from UV, Y from heightmap
    worldPos.x = worldOffset.x + uv.x * float(uChunkSize);
    worldPos.y = height;
    worldPos.z = worldOffset.z + uv.y * float(uChunkSize);
}

float GetVertexTessLevel(vec3 worldPos, vec3 normal, vec3 forward) {
    // 1. DISTANCE FACTOR (The Base)
    float dist = distance(viewPos, worldPos);
    float distanceLevel = uTessLevelMax * exp(-dist * 0.02);
    distanceLevel = clamp(distanceLevel, uTessLevelMin, uTessLevelMax);

    // 2. SILHOUETTE FACTOR (The Boost)
    vec3  viewDir = normalize(viewPos - worldPos);
    float dotProd = dot(normalize(normal), viewDir);
    float isSilhouette = 1.0 - abs(dotProd);
    float silhouetteBoost = mix(1.0, 2.0, isSilhouette * (1 - dist / 500.0));

    // 3. FOCUS FACTOR (The Cull)
    vec3 dirCamToVertex = normalize(worldPos - viewPos);
    float align = dot(dirCamToVertex, forward);
    float focusCull = smoothstep(0.85, 1.0, align);

    // COMBINE
    float finalLevel = distanceLevel * silhouetteBoost;
    finalLevel *= focusCull;
    finalLevel *= uTessQualityMultiplier;

    return step(0, finalLevel) * max(finalLevel, uTessLevelMin);
}

void main() {
    // Pass through local position and UVs
    LocalPos_TC_out[gl_InvocationID] = LocalPos_VS_out[gl_InvocationID];
    TexCoords_TC_out[gl_InvocationID] = TexCoords_VS_out[gl_InvocationID];
    TextureSlice_TC_out[gl_InvocationID] = TextureSlice_VS_out[gl_InvocationID];
    WorldOffset_TC_out[gl_InvocationID] = WorldOffset_VS_out[gl_InvocationID];

    if (gl_InvocationID == 0) {
        if (uIsShadowPass) {
            // For shadow pass, use a reasonable tessellation to capture terrain shape
            // but keep it low enough for performance. 8.0 is a good compromise.
            float slice = TextureSlice_VS_out[0];
            vec3 worldOffset = WorldOffset_VS_out[0];
            vec3 worldPos;
            vec3 normal;
            sampleHeightmap(TexCoords_VS_out[0], slice, worldOffset, worldPos, normal);
            float dist = distance(viewPos, worldPos);


            vec3  viewDir = normalize(viewPos - worldPos);
            float dotProd = dot(normalize(normal), viewDir);
            float isSilhouette = 1.0 - abs(dotProd);
            float shadowTess = mix(1.0, max(8.0, uTessLevelMin), isSilhouette * (1 - dist / 500.0));

            gl_TessLevelOuter[0] = shadowTess;
            gl_TessLevelOuter[1] = shadowTess;
            gl_TessLevelOuter[2] = shadowTess;
            gl_TessLevelOuter[3] = shadowTess;

            gl_TessLevelInner[0] = shadowTess;
            gl_TessLevelInner[1] = shadowTess;
            return;
        }

        // Sample heightmap for all 4 corners to get world positions and normals
        float slice = TextureSlice_VS_out[0];
        vec3 worldOffset = WorldOffset_VS_out[0];

        vec3 worldPos0, worldPos1, worldPos2, worldPos3;
        vec3 normal0, normal1, normal2, normal3;

        sampleHeightmap(TexCoords_VS_out[0], slice, worldOffset, worldPos0, normal0);
        sampleHeightmap(TexCoords_VS_out[1], slice, worldOffset, worldPos1, normal1);
        sampleHeightmap(TexCoords_VS_out[2], slice, worldOffset, worldPos2, normal2);
        sampleHeightmap(TexCoords_VS_out[3], slice, worldOffset, worldPos3, normal3);

        // --- Curvature-based Tessellation ---
        float dot01 = abs(dot(normal0, normal1));
        float dot12 = abs(dot(normal1, normal2));
        float dot23 = abs(dot(normal2, normal3));
        float dot30 = abs(dot(normal3, normal0));

		// Create curvature factors per-edge to ensure consistency between adjacent patches.
		// If the factor used only two vertices of the edge, it will be identical for the same edge in both patches.
		float curv01 = 1.0 - smoothstep(0.95, 0.99, dot01) * 0.9;
		float curv12 = 1.0 - smoothstep(0.95, 0.99, dot12) * 0.9;
		float curv23 = 1.0 - smoothstep(0.95, 0.99, dot23) * 0.9;
		float curv30 = 1.0 - smoothstep(0.95, 0.99, dot30) * 0.9;

        float l0 = GetVertexTessLevel(worldPos0, normal0, viewForward[0]);
        float l1 = GetVertexTessLevel(worldPos1, normal1, viewForward[1]);
        float l2 = GetVertexTessLevel(worldPos2, normal2, viewForward[2]);
        float l3 = GetVertexTessLevel(worldPos3, normal3, viewForward[3]);

        // Correct edge mapping for quad tessellation:
        // Edge 0: Left (u=0, connects p0 and p3)
        // Edge 1: Bottom (v=0, connects p0 and p1)
        // Edge 2: Right (u=1, connects p1 and p2)
        // Edge 3: Top (v=1, connects p2 and p3)
        float edge0 = (l0 + l3) * 0.5 * curvatureFactor;
        float edge1 = (l0 + l1) * 0.5 * curvatureFactor;
        float edge2 = (l1 + l2) * 0.5 * curvatureFactor;
        float edge3 = (l2 + l3) * 0.5 * curvatureFactor;

		// Correct Mapping for Quads:
		// gl_TessLevelOuter[0] -> u=0 (edge 3-0)
		// gl_TessLevelOuter[1] -> v=0 (edge 0-1)
		// gl_TessLevelOuter[2] -> u=1 (edge 1-2)
		// gl_TessLevelOuter[3] -> v=1 (edge 2-3)
		gl_TessLevelOuter[0] = clamp(level30, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[1] = clamp(level01, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[2] = clamp(level12, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[3] = clamp(level23, uTessLevelMin, uTessLevelMax);

		gl_TessLevelInner[0] = max(gl_TessLevelOuter[0], gl_TessLevelOuter[2]);
		gl_TessLevelInner[1] = max(gl_TessLevelOuter[1], gl_TessLevelOuter[3]);
	}
}
