#version 430 core

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct Particle {
    vec4 position; // w component can be used for lifetime or other attributes
    vec4 velocity; // w component can be used for mass or other attributes
};

layout(std430, binding = 0) buffer ParticleBufferIn {
    Particle particlesIn[];
};

layout(std430, binding = 1) buffer ParticleBufferOut {
    Particle particlesOut[];
};

uniform float deltaTime;
uniform sampler2D heightmap;
uniform vec3 worldMin;
uniform vec3 worldMax;
uniform float time;

#include "simplex_noise.glsl"

vec3 curlNoise(vec3 p) {
    const float e = 0.1;
    float n1 = snoise(vec3(p.x, p.y + e, p.z));
    float n2 = snoise(vec3(p.x, p.y - e, p.z));
    float n3 = snoise(vec3(p.x + e, p.y, p.z));
    float n4 = snoise(vec3(p.x - e, p.y, p.z));
    float n5 = snoise(vec3(p.x, p.y, p.z + e));
    float n6 = snoise(vec3(p.x, p.y, p.z - e));

    float x = (n2 - n1) - (n6 - n5);
    float y = (n4 - n3) - (n2 - n1);
    float z = (n6 - n5) - (n4 - n3);

    return normalize(vec3(x, y, z));
}

// Simple pseudo-random function
float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void main() {
    uint index = gl_GlobalInvocationID.x;

    Particle pIn = particlesIn[index];
    vec3 position = pIn.position.xyz;
    vec3 velocity = pIn.velocity.xyz;
    vec3 acceleration = vec3(0.0);

    // --- Forces ---

    // 1. Wind Force (Curl Noise + Constant)
    vec3 noise_coord = position * 0.05 + vec3(0.0, 0.0, time * 0.1);
    vec3 curl = curlNoise(noise_coord) * 5.0;
    vec3 windForce = vec3(2.0, 0.0, 1.0) + curl;
    acceleration += windForce;

    // 2. Altitude-based Gravity
    float altitude = position.y;
    float gravityStrength = -9.8 * (1.0 + altitude * 0.1);
    acceleration += vec3(0.0, gravityStrength, 0.0);

    // 3. Terrain Avoidance Force
    vec2 terrainCoords = (position.xz - worldMin.xz) / (worldMax.xz - worldMin.xz);
    vec4 terrainData = texture(heightmap, terrainCoords);
    vec3 terrainNormal = terrainData.xyz;
    float terrainHeight = terrainData.w * (worldMax.y - worldMin.y) + worldMin.y;

    float distanceToTerrain = position.y - terrainHeight;
    if (distanceToTerrain < 2.0) {
        float avoidanceStrength = 20.0 * (1.0 - smoothstep(0.0, 2.0, distanceToTerrain));
        acceleration += terrainNormal * avoidanceStrength;
    }

    // --- Integration (Euler) ---
    velocity += acceleration * deltaTime;
    position += velocity * deltaTime;

    // --- Boundary Conditions (Wrap around) ---
    if (position.x < worldMin.x) position.x = worldMax.x - (worldMin.x - position.x);
    if (position.x > worldMax.x) position.x = worldMin.x + (position.x - worldMax.x);
    if (position.z < worldMin.z) position.z = worldMax.z - (worldMin.z - position.z);
    if (position.z > worldMax.z) position.z = worldMin.z + (position.z - worldMax.z);

    // Keep particles from flying too high
    if(position.y > worldMax.y * 2.0) {
        vec2 randomXZ = vec2(rand(position.xz), rand(position.zx));
        position.x = mix(worldMin.x, worldMax.x, randomXZ.x);
        position.z = mix(worldMin.z, worldMax.z, randomXZ.y);

        vec2 resetCoords = (position.xz - worldMin.xz) / (worldMax.xz - worldMin.xz);
        position.y = texture(heightmap, resetCoords).r * (worldMax.y - worldMin.y) + worldMin.y + 2.0;
        velocity = vec3(0.0);
    }


    particlesOut[index].position = vec4(position, pIn.position.w);
    particlesOut[index].velocity = vec4(velocity, pIn.velocity.w);
}
