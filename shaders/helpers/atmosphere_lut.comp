#version 430 core

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba32f, binding = 0) uniform image2D transmittanceLUT;

#include "atmosphere.glsl"

float getOpticalDepth(float h, float cosTheta, float scaleHeight) {
	float r = h + EARTH_RADIUS;
	float r2 = r * r;

	// Ray-sphere intersection with atmosphere boundary
	float b = 2.0 * r * cosTheta;
	float c = r2 - ATMOSPHERE_RADIUS * ATMOSPHERE_RADIUS;
	float d = b * b - 4.0 * c;

	if (d < 0.0) return 0.0;
	float t = (-b + sqrt(d)) * 0.5;
	if (t < 0.0) return 0.0;

	const int SAMPLES = 64;
	float stepSize = t / float(SAMPLES);
	float opticalDepth = 0.0;

	for (int i = 0; i < SAMPLES; i++) {
		float ti = (float(i) + 0.5) * stepSize;
		float ri = sqrt(r2 + ti * ti + 2.0 * r * ti * cosTheta);
		float hi = max(0.0, ri - EARTH_RADIUS);
		opticalDepth += exp(-hi / scaleHeight) * stepSize;
	}

	return opticalDepth;
}

void main() {
	ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(transmittanceLUT);

	if (texel.x >= size.x || texel.y >= size.y) return;

	// x: cos(zenith angle) [-1, 1]
	// y: altitude [0, 100km]
	float mu = float(texel.x) / float(size.x - 1) * 2.0 - 1.0;
	float h = float(texel.y) / float(size.y - 1) * 100000.0;

	float odRayleigh = getOpticalDepth(h, mu, RAYLEIGH_HEIGHT);
	float odMie = getOpticalDepth(h, mu, MIE_HEIGHT);

	// Transmittance T = exp(-(beta_r * od_r + beta_m * od_m))
	vec3 transmittance = exp(-(RAYLEIGH_BETA * odRayleigh + MIE_BETA * 1.1 * odMie));

	imageStore(transmittanceLUT, texel, vec4(transmittance, 1.0));
}
