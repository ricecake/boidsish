#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(rgba8, binding = 1) uniform writeonly image3D cloudNoiseLUT;

#include "lygia/generative/worley.glsl"
#include "lygia/generative/snoise.glsl"

// Helper: Remap values to control cloud density/erosion
float remap(float value, float original_min, float original_max, float new_min, float new_max) {
    return new_min + (((value - original_min) / (original_max - original_min)) * (new_max - new_min));
}

// 1. CUSTOM TILED WORLEY
// Lygia's standard worley doesn't expose the tile period, so we implement a
// grid-wrapping version here.
// p: coordinate
// tile: integer repetition frequency (e.g., 4.0, 8.0)
float worleyTiled(vec3 p, float tile) {
    vec3 id = floor(p);
    vec3 fd = fract(p);

    float minDist = 1.0;

    // Search neighbors
    for (int k = -1; k <= 1; k++) {
        for (int j = -1; j <= 1; j++) {
            for (int i = -1; i <= 1; i++) {
                vec3 neighbor = vec3(float(i), float(j), float(k));

                // CRITICAL: Wrap the neighbor lookup for seamless tiling
                // This ensures the point at (0,0,0) matches (tile, tile, tile)
                vec3 uv = id + neighbor;
                uv = mod(uv, tile); // Wrap the grid ID

                // Hash the wrapped grid ID to get a random point offset
                // (Using a simple hash for portability, or use lygia's hash)
                vec3 pointOffset = fract(sin(vec3(dot(uv, vec3(127.1, 311.7, 74.7)),
                                                  dot(uv, vec3(269.5, 183.3, 246.1)),
                                                  dot(uv, vec3(113.5, 271.9, 124.6)))) * 43758.5453);

                // Animate pointOffset here with time if you want internal motion
                // pointOffset = 0.5 + 0.5 * sin(u_time + 6.2831 * pointOffset);

                vec3 diff = neighbor + pointOffset - fd;
                float dist = length(diff);
                minDist = min(minDist, dist);
            }
        }
    }

    // Invert so 1.0 is the center of the cell (billowy)
    return 1.0 - minDist;
}

// 2. FBM CONSTRUCTION
float getCloudNoise(vec3 uv, float tileFreq) {
    // A. Base Cloud Shape (Worley FBM)
    // We layer 3 octaves of Worley noise.
    float w1 = worleyTiled(uv * tileFreq, tileFreq);
    float w2 = worleyTiled(uv * tileFreq * 2.0, tileFreq * 2.0);
    float w3 = worleyTiled(uv * tileFreq * 4.0, tileFreq * 4.0);

    // FBM: Combine with diminishing weights (0.625, 0.25, 0.125)
    float worleyFBM = w1 * 0.625 + w2 * 0.25 + w3 * 0.125;

    // B. Smooth Irregularity (Simplex Noise)
    // We use Simplex to "distort" or "erode" the Worley base.
    // Ensure the simplex frequency is also a multiple of your base tile if you want
    // strict looping, though high-freq simplex often hides seams well enough.
    float simplex = snoise(uv * tileFreq * 2.0);
    simplex = simplex * 0.5 + 0.5; // Remap to 0-1

    // C. The "Perlin-Worley" Mix
    // We use the Simplex noise to erode the Worley noise.
    // As simplex increases, we push the worley value down.
    float finalNoise = remap(worleyFBM, simplex * 0.3, 1.0, 0.0, 1.0);

    return clamp(finalNoise, 0.0, 1.0);
}

// Usage in your main loop
// vec3 texCoord = ... (your 0 to 1 UVW)
// float cloudDensity = getCloudNoise(texCoord, 4.0); // 4.0 = tiles 4 times across texture


void main() {
	ivec3 texel = ivec3(gl_GlobalInvocationID.xyz);
	ivec3 size = imageSize(cloudNoiseLUT);

	if (texel.x >= size.x || texel.y >= size.y || texel.z >= size.z) return;

	vec3 p = vec3(texel) / vec3(size);

	// Generate multi-octave Worley noise
	float v1 = worley(p * 4.0);
	float v2 = worley(p * 8.0);
	float v3 = worley(p * 16.0);
	float v4 = worley(p * 32.0);

	vec4 noise = vec4(v1, v2, v3, v4);

	imageStore(cloudNoiseLUT, texel, noise);
}
