#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(rgba8, binding = 1) uniform writeonly image3D cloudNoiseLUT;

// Helper: Remap values
float remap(float value, float original_min, float original_max, float new_min, float new_max) {
	return new_min + (((value - original_min) / (original_max - original_min)) * (new_max - new_min));
}

// CUSTOM TILED WORLEY
float worleyTiled(vec3 p, float tile) {
	vec3 id = floor(p);
	vec3 fd = fract(p);
	float minDist = 1.0;

	for (int k = -1; k <= 1; k++) {
		for (int j = -1; j <= 1; j++) {
			for (int i = -1; i <= 1; i++) {
				vec3 neighbor = vec3(float(i), float(j), float(k));
				vec3 uv = id + neighbor;
				uv = mod(uv, tile);

				vec3 pointOffset = fract(sin(vec3(
					dot(uv, vec3(127.1, 311.7, 74.7)),
					dot(uv, vec3(269.5, 183.3, 246.1)),
					dot(uv, vec3(113.5, 271.9, 124.6))
				)) * 43758.5453);

				vec3 diff = neighbor + pointOffset - fd;
				float dist = length(diff);
				minDist = min(minDist, dist);
			}
		}
	}
	return clamp(1.0 - minDist, 0.0, 1.0);
}

// Hash function that wraps 'i' on the 'tile' boundary
vec3 wrapHash(vec3 p, float tile) {
	p = mod(p, tile);
	return fract(sin(vec3(
		dot(p, vec3(127.1, 311.7, 74.7)),
		dot(p, vec3(269.5, 183.3, 246.1)),
		dot(p, vec3(113.5, 271.9, 124.6))
	)) * 43758.5453) * 2.0 - 1.0;
}

float gradientNoiseTiled(vec3 p, float tile) {
	vec3 i = floor(p);
	vec3 f = fract(p);
	vec3 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);

	return mix(
		mix(mix(dot(wrapHash(i + vec3(0, 0, 0), tile), f - vec3(0, 0, 0)),
	            dot(wrapHash(i + vec3(1, 0, 0), tile), f - vec3(1, 0, 0)),
	            u.x),
	        mix(dot(wrapHash(i + vec3(0, 1, 0), tile), f - vec3(0, 1, 0)),
	            dot(wrapHash(i + vec3(1, 1, 0), tile), f - vec3(1, 1, 0)),
	            u.x),
	        u.y),
		mix(mix(dot(wrapHash(i + vec3(0, 0, 1), tile), f - vec3(0, 0, 1)),
	            dot(wrapHash(i + vec3(1, 0, 1), tile), f - vec3(1, 0, 1)),
	            u.x),
	        mix(dot(wrapHash(i + vec3(0, 1, 1), tile), f - vec3(0, 1, 1)),
	            dot(wrapHash(i + vec3(1, 1, 1), tile), f - vec3(1, 1, 1)),
	            u.x),
	        u.y),
		u.z
	);
}

void main() {
	ivec3 texel = ivec3(gl_GlobalInvocationID.xyz);
	ivec3 size = imageSize(cloudNoiseLUT);
	vec3  uv = (vec3(texel) + 0.5) / vec3(size);

	// R: Perlin-Worley (Dilated Perlin)
	float perlin = gradientNoiseTiled(uv * 4.0, 4.0) * 0.5 + 0.5;
	float worley0 = worleyTiled(uv * 4.0, 4.0);
	// Perlin dilated by worley: base shape of perlin but with billowy worley edges
	// Using a smaller threshold for dilation to ensure clouds are large enough
	float perlinWorley = remap(perlin, (1.0 - worley0) * 0.4, 1.0, 0.0, 1.0);

	// G, B, A: Layered Worley (FBM)
	float worley1 = worleyTiled(uv * 8.0, 8.0);
	float worley2 = worleyTiled(uv * 16.0, 16.0);
	float worley3 = worleyTiled(uv * 32.0, 32.0);

	imageStore(cloudNoiseLUT, texel, vec4(perlinWorley, worley1, worley2, worley3));
}
