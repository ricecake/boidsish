#version 430 core

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) uniform sampler2D uInputDepth;
layout(binding = 0, r32f) uniform image2D uOutputMips[12];

layout(std430, binding = 2) buffer Counter {
    uint uGroupCount[12];
};

shared float lds[16][16];

uniform ivec2 uBaseSize;
uniform int uNumMips;

void main() {
    ivec2 gPos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 lPos = ivec2(gl_LocalInvocationID.xy);

    // --- Level 0 ---
    float m = 1.0;
    if (gPos.x < uBaseSize.x && gPos.y < uBaseSize.y) {
        m = texelFetch(uInputDepth, gPos, 0).r;
        imageStore(uOutputMips[0], gPos, vec4(m));
    }

    // --- Levels 1-4: Intra-group reduction (16x16 -> 1x1) ---
    lds[lPos.x][lPos.y] = m;

    for (int i = 1; i <= 4; ++i) {
        barrier();
        int step = 1 << i;
        if (i < uNumMips && (lPos.x % step == 0) && (lPos.y % step == 0)) {
            int h = step >> 1;
            m = min(min(lds[lPos.x][lPos.y], lds[lPos.x + h][lPos.y]),
                    min(lds[lPos.x][lPos.y + h], lds[lPos.x + h][lPos.y + h]));
            lds[lPos.x][lPos.y] = m;
            imageStore(uOutputMips[i], gPos / step, vec4(m));
        }
    }

    // --- Levels 5+: Inter-group reduction using atomic coordination ---
    if (lPos.x == 0 && lPos.y == 0 && uNumMips > 5) {
        ivec2 coord = gPos / 16; // Coordinate in Mip 4
        int mip = 5;

        while (mip < uNumMips) {
            // Coordinate with other groups that have reached this mip level
            uint count = atomicAdd(uGroupCount[mip], 1);

            if (count % 4 == 3) {
                // We are the last of the 4 groups in the 2x2 region of mip-1
                ivec2 prevBase = (coord / 2) * 2;
                float d0 = imageLoad(uOutputMips[mip-1], prevBase + ivec2(0, 0)).r;
                float d1 = imageLoad(uOutputMips[mip-1], prevBase + ivec2(1, 0)).r;
                float d2 = imageLoad(uOutputMips[mip-1], prevBase + ivec2(0, 1)).r;
                float d3 = imageLoad(uOutputMips[mip-1], prevBase + ivec2(1, 1)).r;

                m = min(min(d0, d1), min(d2, d3));
                coord /= 2;
                imageStore(uOutputMips[mip], coord, vec4(m));
                mip++;

                // Make sure the store is visible to subsequent loads in other groups
                memoryBarrierImage();
            } else {
                break;
            }
        }
    }
}
