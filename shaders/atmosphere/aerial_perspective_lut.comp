#version 430 core

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;
layout(rgba32f, binding = 0) uniform image3D outAerialPerspective;

uniform sampler2D u_transmittanceLUT;
uniform sampler2D u_multiScatteringLUT;

uniform vec3 u_sunDir;
uniform vec3 u_sunRadiance;
uniform vec3 u_cameraPos;

uniform float u_multiScatScale;
uniform float u_ambientScatScale;

#include "common.glsl"
#include "../lighting.glsl"

vec3 getTransmittance(float r, float mu) {
    vec2 uv = transmittanceToUV(r, mu);
    return texture(u_transmittanceLUT, uv).rgb;
}

vec3 getMultiScattering(float r, float mu_s) {
    vec2 uv = vec2(mu_s * 0.5 + 0.5, (r - kEarthRadius) / kAtmosphereHeight);
    return texture(u_multiScatteringLUT, uv).rgb;
}

void main() {
    ivec3 texel = ivec3(gl_GlobalInvocationID.xyz);
    ivec3 size = imageSize(outAerialPerspective);
    if (any(greaterThanEqual(texel, size))) return;

    vec3 uvw = (vec3(texel) + 0.5) / vec3(size);

    float azimuth = uvw.x * 2.0 * PI;
    float elevation = (uvw.y - 0.5) * PI;
    float maxDist = 32.0; // 32 km for fog
    float dist = uvw.z * maxDist;

    vec3 rd = vec3(cos(elevation) * sin(azimuth), sin(elevation), -cos(elevation) * cos(azimuth));

    float camAltKM = u_cameraPos.y / 1000.0;
    float r = kEarthRadius + camAltKM;
    vec3 ro = vec3(0, r, 0);

    const int kSteps = 16;
    vec3 L = vec3(0.0);
    vec3 T = vec3(1.0);
    float dt = dist / float(kSteps);

    for (int i = 0; i < kSteps; ++i) {
        float t = (float(i) + 0.5) * dt;
        vec3 p = ro + rd * t;
        float h = length(p) - kEarthRadius;
        if (h < 0.0) break; // Hits ground

        Sampling s = getAtmosphereProperties(h);

        float cosSun = dot(normalize(p), u_sunDir);
        vec3 Ts = getTransmittance(length(p), cosSun);

        float cosTheta = dot(rd, u_sunDir);
        vec3 phase = s.rayleigh * rayleighPhase(cosTheta) + s.mie * miePhase(cosTheta);

        vec3 multiScat = getMultiScattering(length(p), cosSun) * u_multiScatScale;

        // Add ambient scattering to prevent pitch blackness at night
        vec3 ambientScattering = ambient_light * (s.rayleigh + s.mie) * u_ambientScatScale;

        vec3 inScattered = (phase * u_sunRadiance * Ts + multiScat * (s.rayleigh + s.mie) + ambientScattering) * dt;
        L += T * inScattered;
        T *= exp(-s.extinction * dt);
    }

    imageStore(outAerialPerspective, texel, vec4(L, (T.r + T.g + T.b) / 3.0));
}
