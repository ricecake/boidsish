#version 430 core

layout(local_size_x = 32, local_size_y = 32) in;
layout(rgba32f, binding = 0) uniform image2D outMultiScattering;

uniform sampler2D u_transmittanceLUT;

#include "common.glsl"

vec3 getTransmittance(float r, float mu) {
    vec2 uv = transmittanceToUV(r, mu);
    return texture(u_transmittanceLUT, uv).rgb;
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    vec2 size = vec2(imageSize(outMultiScattering));

    float cosSun = (float(texel.x) / size.x) * 2.0 - 1.0;
    float r = kEarthRadius + (float(texel.y) / size.y) * kAtmosphereHeight;

    const int nSamples = 64;
    vec3 totalL = vec3(0.0);
    vec3 totalF = vec3(0.0);

    // Sample directions over the sphere
    for (int i = 0; i < nSamples; ++i) {
        // Simple uniform sampling of directions
        float phi = 2.0 * PI * (float(i) / float(nSamples));
        float theta = acos(1.0 - 2.0 * (float(i) + 0.5) / float(nSamples));
        vec3 rd = vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));

        float mu = rd.y;
        float cosTheta = rd.x * sqrt(1.0 - cosSun * cosSun) + rd.y * cosSun; // Simplified

        // Single bounce scattering contribution
        float t0, t1;
        if (intersectSphere(vec3(0, r, 0), rd, kTopRadius, t0, t1)) {
            float t_max = t1;
            float p0, p1;
            if (intersectSphere(vec3(0, r, 0), rd, kEarthRadius, p0, p1) && p0 > 0.0) t_max = p0;

            float t = t_max * 0.5; // Single point approximation
            float h = length(vec3(0, r, 0) + rd * t) - kEarthRadius;
            Sampling s = getAtmosphereProperties(h);
            vec3 T = getTransmittance(r + h, cosSun); // Transmittance to sun

            totalL += (s.rayleigh * rayleighPhase(cosSun) + s.mie * miePhase(cosSun)) * T * t_max;
            totalF += (s.rayleigh + s.mie) * t_max;
        }
    }

    vec3 multiScat = totalL / max(vec3(1.0) - totalF / float(nSamples), 0.001);
    imageStore(outMultiScattering, texel, vec4(multiScat / float(nSamples), 1.0));
}
