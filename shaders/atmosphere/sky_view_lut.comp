#version 430 core

layout(local_size_x = 8, local_size_y = 8) in;
layout(rgba32f, binding = 0) uniform image2D outSkyView;

uniform sampler2D u_transmittanceLUT;
uniform sampler2D u_multiScatteringLUT;

uniform vec3 u_sunDir;
uniform vec3 u_sunRadiance;
uniform vec3 u_cameraPos;

uniform float u_multiScatScale;

#include "common.glsl"

vec3 getTransmittance(float r, float mu) {
    vec2 uv = transmittanceToUV(r, mu);
    return texture(u_transmittanceLUT, uv).rgb;
}

vec3 getMultiScattering(float r, float mu_s) {
    vec2 uv = vec2(mu_s * 0.5 + 0.5, (r - kEarthRadius) / kAtmosphereHeight);
    return texture(u_multiScatteringLUT, uv).rgb;
}

void main() {
    ivec2 texel = ivec2(gl_GlobalInvocationID.xy);
    vec2 size = vec2(imageSize(outSkyView));
    if (any(greaterThanEqual(texel, ivec2(size)))) return;

    vec2 uv = (vec2(texel) + 0.5) / size;

    // Mapping from UV to direction
    float azimuth = uv.x * 2.0 * PI;
    float adjV = (uv.y < 0.5) ? (1.0 - 2.0 * uv.y) : (2.0 * uv.y - 1.0);
    adjV = adjV * adjV;
    float elevation = (uv.y < 0.5) ? (-adjV * PI * 0.5) : (adjV * PI * 0.5);

    vec3 rd = vec3(cos(elevation) * sin(azimuth), sin(elevation), -cos(elevation) * cos(azimuth));

    float camAltKM = u_cameraPos.y / 1000.0;
    float r = kEarthRadius + camAltKM;
    vec3 ro = vec3(0, r, 0);

    float t0, t1;
    if (!intersectSphere(ro, rd, kTopRadius, t0, t1)) {
        imageStore(outSkyView, texel, vec4(0.0));
        return;
    }

    float t_max = t1;
    float p0, p1;
    bool intersectsPlanet = intersectSphere(ro, rd, kEarthRadius, p0, p1);
    if (intersectsPlanet && p0 > 0.0) t_max = p0;

    const int kSteps = 32;
    vec3 L = vec3(0.0);
    vec3 T = vec3(1.0);
    float dt = t_max / float(kSteps);

    for (int i = 0; i < kSteps; ++i) {
        float t = (float(i) + 0.5) * dt;
        vec3 p = ro + rd * t;
        float h = length(p) - kEarthRadius;
        Sampling s = getAtmosphereProperties(h);

        float cosSun = dot(normalize(p), u_sunDir);
        vec3 Ts = getTransmittance(length(p), cosSun);

        float cosTheta = dot(rd, u_sunDir);
        vec3 phase = s.rayleigh * rayleighPhase(cosTheta) + s.mie * miePhase(cosTheta);

        vec3 multiScat = getMultiScattering(length(p), cosSun) * u_multiScatScale;

        vec3 inScattered = (phase * u_sunRadiance * Ts + multiScat * (s.rayleigh + s.mie)) * dt;
        L += T * inScattered;
        T *= exp(-s.extinction * dt);
    }

    imageStore(outSkyView, texel, vec4(L, 1.0));
}
