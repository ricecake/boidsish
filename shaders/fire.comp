#version 430 core

// Must match the C++ struct layout in fire_effect.h
struct Particle {
    vec4 pos;           // Position (w is lifetime)
    vec4 vel;           // Velocity (w is unused)
    int  style;
    int  emitter_index; // Index of the emitter that spawned this particle
    vec2 _padding;      // Explicit padding to align to 16 bytes
};

// Must match the C++ Emitter struct in fire_effect_manager.h
struct Emitter {
    vec3  position;
    int   style;
    vec3  direction;
    float _padding1;
    vec3  velocity;
    float _padding2;
};


layout(std430, binding = 0) buffer ParticleBuffer {
    Particle particles[];
};

layout(std430, binding = 1) buffer EmitterBuffer {
    Emitter emitters[];
};

uniform float u_delta_time;
uniform float u_time;
uniform int   u_num_emitters;

// Basic pseudo-random number generator
float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

// 3D random number generator
vec3 rand3(vec2 co) {
    return vec3(
        rand(co + vec2(0.1, 0.2)),
        rand(co + vec2(0.3, 0.4)),
        rand(co + vec2(0.5, 0.6))
    );
}

// Simulation parameters
const float kExhaustSpeed = 25.0;
const float kExhaustSpread = 0.3;
const float kExhaustLifetime = 0.5;

const float kExplosionSpeed = 30.0;
const float kExplosionLifetime = 1.5;
const float kExplosionDrag = 2.0;

const float kFireSpeed = 1.0;
const float kFireSpread = 0.8;
const float kFireLifetime = 2.0;


layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main() {
    uint gid = gl_GlobalInvocationID.x;

    if (gid >= particles.length() || u_num_emitters == 0) {
        return;
    }

    Particle p = particles[gid];

    // Decrease lifetime
    p.pos.w -= u_delta_time;

    // If particle is dead, try to respawn it
    if (p.pos.w <= 0.0) {
        // Deterministic mapping from particle to emitter
        int emitter_index = int(gid % u_num_emitters);
        Emitter emitter = emitters[emitter_index];

        p.emitter_index = emitter_index;
        p.style = emitter.style;

        vec2 seed = vec2(float(gid), u_time);
        vec3 random_vec = rand3(seed) * 2.0 - 1.0;

        // Initialize based on style
        if (p.style == 0) { // MissileExhaust
            p.pos = vec4(emitter.position, kExhaustLifetime);
            vec3 perpendicular = normalize(cross(emitter.direction, random_vec));
            vec3 spread_dir = mix(emitter.direction, perpendicular, kExhaustSpread * rand(seed.yx));
            p.vel = vec4(emitter.velocity + normalize(spread_dir) * kExhaustSpeed, 0.0);
        }
        else if (p.style == 1) { // Explosion
            p.pos = vec4(emitter.position, kExplosionLifetime * rand(seed));
            p.vel = vec4(normalize(random_vec) * kExplosionSpeed * rand(seed.yx), 0.0);
        }
        else if (p.style == 2) { // Fire
            p.pos = vec4(emitter.position + random_vec * 0.1, kFireLifetime * rand(seed));
            p.vel = vec4(0, kFireSpeed, 0, 0); // Start with upward velocity
        }
    }
    // If particle is alive, update it
    else {
        if (p.style == 1) { // Explosion
            p.vel.xyz -= p.vel.xyz * kExplosionDrag * u_delta_time;
        }
        else if (p.style == 2) { // Fire
            p.vel.y += kFireSpeed * u_delta_time;
            p.vel.x += (rand(p.pos.xy + u_time) - 0.5) * kFireSpread * u_delta_time;
            p.vel.z += (rand(p.pos.yz + u_time) - 0.5) * kFireSpread * u_delta_time;
        }
        p.pos.xyz += p.vel.xyz * u_delta_time;
    }

    particles[gid] = p;
}
