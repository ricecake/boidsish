#version 420 core

layout(vertices = 3) out;

in vec3 WorldPos_VS_out[];
in vec2 TexCoords_VS_out[];
in vec3 Normal_VS_out[];
in vec3 viewForward_in[];
in vec3 Color_VS_out[];

out vec3 WorldPos_TC_out[];
out vec2 TexCoords_TC_out[];
out vec3 Normal_TC_out[];
out vec3 Color_TC_out[];

layout(std140, binding = 0) uniform Lighting {
	vec3  lightPos;
	vec3  viewPos;
	vec3  lightColor;
	float time;
};

uniform float uTessLevelMax = 64.0;
uniform float uTessLevelMin = 1.0;
uniform float uTessQualityMultiplier = 1.0;

float GetVertexTessLevel(vec3 worldPos, vec3 normal, vec3 forward) {
	// 1. DISTANCE FACTOR (The Base)
	float dist = distance(viewPos, worldPos);
	float distanceLevel = uTessLevelMax / (dist / 8.0);
	distanceLevel = clamp(distanceLevel, uTessLevelMin, uTessLevelMax);

	// 2. SILHOUETTE FACTOR (The Boost)
	vec3  viewDir = normalize(viewPos - worldPos);
	float dotProd = dot(normalize(normal), viewDir);
	// 0.0 = Facing Camera, 1.0 = Silhouette
	float isSilhouette = 1.0 - abs(dotProd);

	// "Bump" logic:
	// If facing camera, use 1.0x the DistanceLevel.
	// If silhouette, use 3.0x the DistanceLevel (up to Max).
	// This ensures flat ground is still smooth, but edges are SUPER smooth.
	float silhouetteBoost = mix(1.0, 3.0, isSilhouette);

	// 3. FOCUS FACTOR (The Cull)
	// Vector from Camera -> Vertex
	vec3 dirCamToVertex = normalize(worldPos - viewPos);
	// Dot of CameraLook and VertexDir. 1.0 = Center Screen.
	float align = dot(dirCamToVertex, forward);

	// Drop detail rapidly if it's not in front of the camera
	// If align < 0.7 (approx 45 degrees), detail drops to 0
	float focusCull = smoothstep(0.8, 1.0, align);

	// COMBINE
	// We multiply the Base Distance Level by the Silhouette Boost
	float finalLevel = distanceLevel * silhouetteBoost;

	// Then we fade out things that are out of focus/off-screen
	finalLevel *= focusCull;
	finalLevel *= uTessQualityMultiplier;

	// Ensure we never drop below 1 (which would delete the mesh)
	// unless we are culling completely.
	return step(0, finalLevel) * max(finalLevel, uTessLevelMin);
}

void main() {
	WorldPos_TC_out[gl_InvocationID] = WorldPos_VS_out[gl_InvocationID];
	TexCoords_TC_out[gl_InvocationID] = TexCoords_VS_out[gl_InvocationID];
	Normal_TC_out[gl_InvocationID] = Normal_VS_out[gl_InvocationID];
	Color_TC_out[gl_InvocationID] = Color_VS_out[gl_InvocationID];

	if (gl_InvocationID == 0) {
		// --- Curvature-based Tessellation for Triangles ---
		vec3 n0 = normalize(Normal_VS_out[0]);
		vec3 n1 = normalize(Normal_VS_out[1]);
		vec3 n2 = normalize(Normal_VS_out[2]);

		float dot01 = abs(dot(n0, n1));
		float dot12 = abs(dot(n1, n2));
		float dot20 = abs(dot(n2, n0));

		float avgDot = (dot01 + dot12 + dot20) / 3.0;
		float curvatureFactor = 1.0 - smoothstep(0.95, 0.99, avgDot) * 0.9;

		float l0 = GetVertexTessLevel(WorldPos_VS_out[0], Normal_VS_out[0], viewForward_in[0]);
		float l1 = GetVertexTessLevel(WorldPos_VS_out[1], Normal_VS_out[1], viewForward_in[1]);
		float l2 = GetVertexTessLevel(WorldPos_VS_out[2], Normal_VS_out[2], viewForward_in[2]);

		// Outer tessellation levels for the 3 edges of the triangle
		float edge0 = (l1 + l2) * 0.5 * curvatureFactor;
		float edge1 = (l2 + l0) * 0.5 * curvatureFactor;
		float edge2 = (l0 + l1) * 0.5 * curvatureFactor;

		gl_TessLevelOuter[0] = clamp(edge0, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[1] = clamp(edge1, uTessLevelMin, uTessLevelMax);
		gl_TessLevelOuter[2] = clamp(edge2, uTessLevelMin, uTessLevelMax);

		// Inner tessellation level
		gl_TessLevelInner[0] = (gl_TessLevelOuter[0] + gl_TessLevelOuter[1] + gl_TessLevelOuter[2]) / 3.0;
	}
}
