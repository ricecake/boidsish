#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(std430, binding = 0) buffer DecorInstances {
	mat4 instances[];
};

layout(binding = 0) uniform atomic_uint instanceCount;

uniform sampler2D u_heightmap;
uniform vec2      u_cameraPos;
uniform vec2      u_heightmapWorldPos;
uniform float     u_heightmapWorldSize;
uniform float     u_maxTerrainHeight;

uniform float u_density;
uniform float u_baseScale;
uniform float u_scaleVariance;
uniform float u_minHeight;
uniform float u_maxHeight;
uniform float u_minSlope;
uniform float u_maxSlope;
uniform int   u_typeIndex;

// Simple hash for random values
float hash(uint x) {
	x = ((x >> 16) ^ x) * 0x45d9f3b;
	x = ((x >> 16) ^ x) * 0x45d9f3b;
	x = (x >> 16) ^ x;
	return float(x) / 4294967295.0;
}

void main() {
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;

	// Total grid size is 64x64 for now (matching glDispatchCompute in C++)
	float gridSize = 64.0;
	float step = 400.0 / gridSize; // Cover 400 units around camera

	vec2 snappedCameraPos = floor(u_cameraPos / step) * step;
	vec2 offset = vec2(float(x) - gridSize / 2.0, float(y) - gridSize / 2.0) * step;
	vec2 worldPos = snappedCameraPos + offset;

	// Use world position for stable seeding
	uint seedX = uint(abs(worldPos.x));
	uint seedY = uint(abs(worldPos.y));
	uint seed = (seedX * 1973 + seedY * 9277 + uint(u_typeIndex) * 26699) | 1u;

	// Add some jitter
	worldPos += vec2(hash(seed), hash(seed + 1234u)) * step;

	// Map world pos to heightmap UV
	vec2 uv = (worldPos - u_heightmapWorldPos) / u_heightmapWorldSize;

	if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)
		return;

	vec4  terrainSample = textureLod(u_heightmap, uv, 0.0);
	float height = terrainSample.a * u_maxTerrainHeight;
	vec3  normal = terrainSample.rgb * 2.0 - 1.0;

	// Check constraints
	if (height < u_minHeight || height > u_maxHeight)
		return;
	float slope = 1.0 - normal.y; // 0 is flat, 1 is vertical
	if (slope < u_minSlope || slope > u_maxSlope)
		return;

	// Random density check
	if (hash(seed + 5678) > u_density)
		return;

	// We want to place it!
	uint index = atomicCounterIncrement(instanceCount);
	if (index >= 10000)
		return; // Hardcoded max for now

	// Create model matrix
	float s = u_baseScale + (hash(seed + 9012) * 2.0 - 1.0) * u_scaleVariance;
	mat4  m = mat4(1.0);

	// Translation
	m[3] = vec4(worldPos.x, height, worldPos.y, 1.0);

	// Scale (applying scale to the matrix)
	// Simple random Y rotation
	float angle = hash(seed + 3456) * 6.28318;
	float c = cos(angle);
	float si = sin(angle);

	m[0][0] = c * s;
	m[0][2] = si * s;
	m[1][1] = s;
	m[2][0] = -si * s;
	m[2][2] = c * s;

	instances[index] = m;
}
