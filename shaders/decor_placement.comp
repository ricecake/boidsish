#version 430 core

#include "helpers/noise.glsl"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Binding 0: Instance matrices (fixed offsets per chunk)
layout(std430, binding = 0) buffer DecorInstances {
	mat4 instances[];
};

struct ChunkData {
	vec2  worldOffset;
	float textureSlice;
	float chunkSize;
	float minY;
	float maxY;
	uint  version;
	uint  isActive;
};

// Binding 1: Chunk information
layout(std430, binding = 1) buffer TerrainChunks {
	ChunkData chunks[];
};

struct DrawElementsIndirectCommand {
	uint count;
	uint instanceCount;
	uint firstIndex;
	uint baseVertex;
	uint baseInstance;
};

// Binding 2: Indirect draw commands
layout(std430, binding = 2) buffer IndirectCommands {
	DrawElementsIndirectCommand commands[];
};

struct ChunkStatus {
	uint lastVersion;
	uint lastWasVisible;
	uint generatedCount;
	uint padding;
};

// Binding 3: Persistent status
layout(std430, binding = 3) buffer TerrainChunkStatus {
	ChunkStatus statuses[];
};

shared uint s_instanceCount;

uniform sampler2DArray u_heightmapArray;
uniform vec2           u_cameraPos;
uniform float          u_maxTerrainHeight;
uniform vec4           u_frustumPlanes[6];
uniform float          u_densityFalloffStart;
uniform float          u_densityFalloffEnd;
uniform float          u_maxDecorDistance;
uniform float          u_minDensity;
uniform float          u_maxDensity;
uniform float          u_baseScale;
uniform float          u_scaleVariance;
uniform float          u_minHeight;
uniform float          u_maxHeight;
uniform float          u_minSlope;
uniform float          u_maxSlope;
uniform vec3           u_baseRotation;
uniform bool           u_randomYaw;
uniform bool           u_alignToTerrain;
uniform int            u_typeIndex;
uniform float          u_worldScale;
uniform int            u_maxInstancesPerChunk;
uniform int            u_maxChunks;
uniform int            u_numMeshes;

float hash(uint x) {
	x = ((x >> 16) ^ x) * 0x45d9f3b;
	x = ((x >> 16) ^ x) * 0x45d9f3b;
	x = (x >> 16) ^ x;
	return float(x) / 4294967295.0;
}

bool isInFrustum(vec3 pos) {
	for (int i = 0; i < 6; i++) {
		if (dot(u_frustumPlanes[i].xyz, pos) + u_frustumPlanes[i].w < -5.0) return false;
	}
	return true;
}

bool isBoxInFrustum(vec3 minCorner, vec3 maxCorner) {
	for (int i = 0; i < 6; i++) {
		vec3 positiveVertex = vec3(
			u_frustumPlanes[i].x >= 0 ? maxCorner.x : minCorner.x,
			u_frustumPlanes[i].y >= 0 ? maxCorner.y : minCorner.y,
			u_frustumPlanes[i].z >= 0 ? maxCorner.z : minCorner.z
		);
		if (dot(u_frustumPlanes[i].xyz, positiveVertex) + u_frustumPlanes[i].w < 0) return false;
	}
	return true;
}

mat3 rotationFromEuler(vec3 angles) {
	float cx = cos(angles.x), sx = sin(angles.x), cy = cos(angles.y), sy = sin(angles.y), cz = cos(angles.z), sz = sin(angles.z);
	return mat3(cy, 0, sy, 0, 1, 0, -sy, 0, cy) * mat3(1, 0, 0, 0, cx, -sx, 0, sx, cx) * mat3(cz, -sz, 0, sz, cz, 0, 0, 0, 1);
}

void processPoint(uint x, uint y, ChunkData chunk, uint seedBase) {
	float step = chunk.chunkSize / 32.0;
	vec2 worldPos = chunk.worldOffset + vec2(float(x), float(y)) * step;
	uint seed = seedBase + (x * 32 + y);
	worldPos += vec2(hash(seed), hash(seed + 1234u)) * step * 0.9;

	if (worldPos.x < chunk.worldOffset.x || worldPos.x >= chunk.worldOffset.x + chunk.chunkSize ||
	    worldPos.y < chunk.worldOffset.y || worldPos.y >= chunk.worldOffset.y + chunk.chunkSize) return;

	vec2 uv = (worldPos - chunk.worldOffset) / chunk.chunkSize;
	vec4 terrainSample = textureLod(u_heightmapArray, vec3(uv, chunk.textureSlice), 0.0);
	float height = terrainSample.r;
	vec3 normal = vec3(terrainSample.g, terrainSample.b, terrainSample.a);

	if (height < u_minHeight * u_worldScale || height > u_maxHeight * u_worldScale) return;
	if (1.0 - normal.y < u_minSlope || 1.0 - normal.y > u_maxSlope) return;

	vec2 scaledWorldPos = worldPos / u_worldScale;
	float noiseVal = (snoise(scaledWorldPos * 0.01) * 0.7 + snoise(scaledWorldPos * 0.05) * 0.3 + 1.0) * 0.5;
	float effectiveDensity = mix(u_minDensity, u_maxDensity, clamp(noiseVal, 0.0, 1.0));

	float distToCam = distance(worldPos, u_cameraPos);
	effectiveDensity *= mix(0.2, 1.0, 1.0 - smoothstep(u_densityFalloffStart, u_densityFalloffEnd, distToCam));

	if (distToCam > u_maxDecorDistance || hash(seed + 5678) > effectiveDensity) return;

	vec3 worldPos3D = vec3(worldPos.x, height, worldPos.y);
	if (!isInFrustum(worldPos3D)) return;

	uint localIdx = atomicAdd(s_instanceCount, 1);
	if (localIdx >= u_maxInstancesPerChunk) return;

	float s = (u_baseScale + ((snoise(scaledWorldPos * 0.1) + 1.0) * 0.5 * 2.0 - 1.0) * u_scaleVariance) * u_worldScale;
	vec3 rotation = u_baseRotation;
	if (u_randomYaw) rotation.y += hash(seed + 3456) * 6.28318;
	mat3 rotMat = rotationFromEuler(rotation);

	if (u_alignToTerrain) {
		vec3 up = vec3(0.0, 1.0, 0.0), tUp = normalize(normal);
		float d = dot(up, tUp);
		if (abs(d) < 0.99) {
			vec3 axis = normalize(cross(up, tUp));
			float a = acos(clamp(d, -1.0, 1.0)), c = cos(a), si = sin(a), t = 1.0 - c;
			rotMat = mat3(t*axis.x*axis.x+c, t*axis.x*axis.y-si*axis.z, t*axis.x*axis.z+si*axis.y,
			              t*axis.x*axis.y+si*axis.z, t*axis.y*axis.y+c, t*axis.y*axis.z-si*axis.x,
			              t*axis.x*axis.z-si*axis.y, t*axis.y*axis.z+si*axis.x, t*axis.z*axis.z+c) * rotMat;
		}
	}

	mat3 scaledRot = rotMat * s;
	mat4 m = mat4(1.0);
	m[0] = vec4(scaledRot[0], 0.0); m[1] = vec4(scaledRot[1], 0.0); m[2] = vec4(scaledRot[2], 0.0); m[3] = vec4(worldPos3D, 1.0);
	instances[uint(gl_WorkGroupID.z) * u_maxInstancesPerChunk + localIdx] = m;
}

void main() {
	uint chunkIdx = gl_WorkGroupID.z;
	if (chunkIdx >= u_maxChunks) return;

	ChunkData chunk = chunks[chunkIdx];
	uint statusIdx = u_typeIndex * u_maxChunks + chunkIdx;

	if (chunk.isActive == 0) {
		if (gl_LocalInvocationIndex == 0) {
			for (int m = 0; m < u_numMeshes; ++m) commands[m * u_maxChunks + chunkIdx].instanceCount = 0;
			statuses[statusIdx].lastWasVisible = 0;
		}
		return;
	}

	// Generous AABB for culling (padding for decor height)
	vec3 chunkMin = vec3(chunk.worldOffset.x, chunk.minY - 10.0, chunk.worldOffset.y);
	vec3 chunkMax = vec3(chunk.worldOffset.x + chunk.chunkSize, chunk.maxY + 50.0, chunk.worldOffset.y + chunk.chunkSize);

	bool visible = isBoxInFrustum(chunkMin, chunkMax);

	// Distance check for generation (preload)
	vec2 chunkCenter = chunk.worldOffset + vec2(chunk.chunkSize * 0.5);
	float distToChunk = distance(chunkCenter, u_cameraPos);
	bool shouldGenerate = (distToChunk < u_maxDecorDistance + chunk.chunkSize);

	if (!shouldGenerate) {
		if (gl_LocalInvocationIndex == 0) {
			for (int m = 0; m < u_numMeshes; ++m) commands[m * u_maxChunks + chunkIdx].instanceCount = 0;
			statuses[statusIdx].lastWasVisible = 0;
		}
		return;
	}

	bool needsRegen = (chunk.version != statuses[statusIdx].lastVersion) || (statuses[statusIdx].lastWasVisible == 0);

	if (needsRegen) {
		if (gl_LocalInvocationIndex == 0) s_instanceCount = 0;
	}
	barrier();

	if (needsRegen) {
		uint seedBase = (uint(abs(chunk.worldOffset.x)) * 1973 + uint(abs(chunk.worldOffset.y)) * 9277 + uint(u_typeIndex) * 26699) | 1u;
		processPoint(gl_LocalInvocationID.x * 2 + 0, gl_LocalInvocationID.y * 2 + 0, chunk, seedBase);
		processPoint(gl_LocalInvocationID.x * 2 + 1, gl_LocalInvocationID.y * 2 + 0, chunk, seedBase);
		processPoint(gl_LocalInvocationID.x * 2 + 0, gl_LocalInvocationID.y * 2 + 1, chunk, seedBase);
		processPoint(gl_LocalInvocationID.x * 2 + 1, gl_LocalInvocationID.y * 2 + 1, chunk, seedBase);
	}
	barrier();

	if (needsRegen) {
		if (gl_LocalInvocationIndex == 0) {
			statuses[statusIdx].generatedCount = min(s_instanceCount, uint(u_maxInstancesPerChunk));
			statuses[statusIdx].lastVersion = chunk.version;
			statuses[statusIdx].lastWasVisible = 1;
		}
	}
	barrier();

	if (gl_LocalInvocationIndex == 0) {
		uint finalCount = visible ? statuses[statusIdx].generatedCount : 0;
		for (int m = 0; m < u_numMeshes; ++m) {
			commands[m * u_maxChunks + chunkIdx].instanceCount = finalCount;
		}
	}
}
