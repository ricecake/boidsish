#version 420 core

layout(triangles, equal_spacing, cw) in;

// Input from Tessellation Control Shader
in vec3 WorldPos_TC_out[];
in vec2 TexCoords_TC_out[];
in vec3 Normal_TC_out[];
in vec3 viewForward_TC_out[];
in vec3 vs_color_TC_out[];
in vec3 barycentric_TC_out[];

// Output to Fragment Shader
out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;
out vec3 vs_color;
out vec3 barycentric;

uniform mat4 view;
uniform mat4 projection;

void main() {
    // Barycentric interpolation of vertex attributes
    vec3 p0 = WorldPos_TC_out[0];
    vec3 p1 = WorldPos_TC_out[1];
    vec3 p2 = WorldPos_TC_out[2];
    FragPos = gl_TessCoord.x * p0 + gl_TessCoord.y * p1 + gl_TessCoord.z * p2;

    vec3 n0 = Normal_TC_out[0];
    vec3 n1 = Normal_TC_out[1];
    vec3 n2 = Normal_TC_out[2];
    Normal = normalize(gl_TessCoord.x * n0 + gl_TessCoord.y * n1 + gl_TessCoord.z * n2);

    vec2 t0 = TexCoords_TC_out[0];
    vec2 t1 = TexCoords_TC_out[1];
    vec2 t2 = TexCoords_TC_out[2];
    TexCoords = gl_TessCoord.x * t0 + gl_TessCoord.y * t1 + gl_TessCoord.z * t2;

    vec3 c0 = vs_color_TC_out[0];
    vec3 c1 = vs_color_TC_out[1];
    vec3 c2 = vs_color_TC_out[2];
    vs_color = gl_TessCoord.x * c0 + gl_TessCoord.y * c1 + gl_TessCoord.z * c2;

    vec3 b0 = barycentric_TC_out[0];
    vec3 b1 = barycentric_TC_out[1];
    vec3 b2 = barycentric_TC_out[2];
    barycentric = gl_TessCoord.x * b0 + gl_TessCoord.y * b1 + gl_TessCoord.z * b2;

    // Final vertex position
    gl_Position = projection * view * vec4(FragPos, 1.0);
}
