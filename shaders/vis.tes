#version 420 core

layout(triangles, fractional_odd_spacing, cw) in;

#include "visual_effects.glsl"

// Input from Tessellation Control Shader
in vec3 WorldPos_TC_out[];
in vec2 TexCoords_TC_out[];
in vec3 Normal_TC_out[];

// Output to Fragment Shader
out vec3  FragPos;
out vec3  Normal;
out vec2  TexCoords;
out vec3  barycentric;
out vec3  vs_color; // Dummy output to match fragment shader input
out float gl_ClipDistance[1];

uniform mat4  view;
uniform mat4  projection;
uniform vec4  clipPlane;
uniform float ripple_strength;
uniform float uPhongAlpha = 1; // Controls the "puffiness" (0.0 = flat, 1.0 = full phong)

layout(std140, binding = 0) uniform Lighting {
	vec3  lightPos;
	vec3  viewPos;
	vec3  lightColor;
	float time;
};

// Helper: Interpolate any vec3 using barycentric coordinates
vec3 barycentric_interp(vec3 v0, vec3 v1, vec3 v2) {
	return v0 * gl_TessCoord.x + v1 * gl_TessCoord.y + v2 * gl_TessCoord.z;
}

// Helper: Interpolate any vec2 using barycentric coordinates
vec2 barycentric_interp(vec2 v0, vec2 v1, vec2 v2) {
	return v0 * gl_TessCoord.x + v1 * gl_TessCoord.y + v2 * gl_TessCoord.z;
}

// Function to apply a "glitch" effect by displacing vertices (copied from visual_effects.vert)
vec3 applyGlitch(vec3 position, float time) {
	float glitch_strength = 0.1;
	float glitch_frequency = 10.0;
	float displacement = sin(position.y * glitch_frequency + time) * glitch_strength;
	return position + vec3(displacement, 0.0, 0.0);
}

vec3 projectPointOnPlane(vec3 q, vec3 v, vec3 n) {
	return q - dot(q - v, n) * n;
}

void main() {
	// 1. Interpolate attributes from the control patch vertices
	vec3 q = barycentric_interp(WorldPos_TC_out[0], WorldPos_TC_out[1], WorldPos_TC_out[2]);
	vec3 n = normalize(barycentric_interp(Normal_TC_out[0], Normal_TC_out[1], Normal_TC_out[2]));
	TexCoords = barycentric_interp(TexCoords_TC_out[0], TexCoords_TC_out[1], TexCoords_TC_out[2]);

	// 2. Phong Tessellation
	vec3 p0 = projectPointOnPlane(q, WorldPos_TC_out[0], Normal_TC_out[0]);
	vec3 p1 = projectPointOnPlane(q, WorldPos_TC_out[1], Normal_TC_out[1]);
	vec3 p2 = projectPointOnPlane(q, WorldPos_TC_out[2], Normal_TC_out[2]);
	vec3 posCurved = barycentric_interp(p0, p1, p2);
	vec3 phong_pos = mix(q, posCurved, uPhongAlpha);

	// 3. Apply vertex displacement effects (moved from vis.vert)
	vec3 displacedPos = phong_pos;
	vec3 displacedNormal = n;

	if (glitched_enabled == 1) {
		displacedPos = applyGlitch(displacedPos, time);
	}

	if (ripple_strength > 0.0) {
		float frequency = 20.0;
		float speed = 3.0;
		float amplitude = ripple_strength;

		float wave = sin(frequency * (phong_pos.x + phong_pos.z) + time * speed);
		displacedPos = phong_pos + n * wave * amplitude;

		vec3 gradient = vec3(
			cos(frequency * (phong_pos.x + phong_pos.z) + time * speed) * frequency * amplitude,
			0.0,
			cos(frequency * (phong_pos.x + phong_pos.z) + time * speed) * frequency * amplitude
		);
		displacedNormal = normalize(n - gradient);
	}

	// 4. Final transformations and outputs
	FragPos = displacedPos;
	Normal = displacedNormal;
	vs_color = vec3(1.0, 1.0, 1.0); // Dummy color

	// The getBarycentric() trick from vis.vert doesn't work in a TES
	// because gl_VertexID is not available. So wireframe is disabled for tessellated objects.
	barycentric = vec3(0.0);

	gl_Position = projection * view * vec4(FragPos, 1.0);
	gl_ClipDistance[0] = dot(vec4(FragPos, 1.0), clipPlane);
}