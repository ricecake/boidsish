#version 420 core

layout(triangles, fractional_odd_spacing, cw) in;

#include "visual_effects.glsl"

// Input from Tessellation Control Shader
in vec3 WorldPos_TC_out[];
in vec2 TexCoords_TC_out[];
in vec3 Normal_TC_out[];
in vec3 Color_TC_out[];

// Output to Fragment Shader
out vec3  FragPos;
out vec3  Normal;
out vec2  TexCoords;
out vec3  vs_color;
out vec3  barycentric; // Used for wireframe effect in fragment shader
out float gl_ClipDistance[1];

uniform mat4  view;
uniform mat4  projection;
uniform vec4  clipPlane;
uniform float ripple_strength;
uniform float uPhongAlpha = 1; // Controls the "puffiness" (0.0 = flat, 1.0 = full phong)

layout(std140, binding = 0) uniform Lighting {
	vec3  lightPos;
	vec3  viewPos;
	vec3  lightColor;
	float time;
};

// Helper: Interpolate any vec3 using barycentric coordinates
vec3 barycentric_interp(vec3 v0, vec3 v1, vec3 v2) {
	return v0 * gl_TessCoord.x + v1 * gl_TessCoord.y + v2 * gl_TessCoord.z;
}

// Helper: Interpolate any vec2 using barycentric coordinates
vec2 barycentric_interp(vec2 v0, vec2 v1, vec2 v2) {
	return v0 * gl_TessCoord.x + v1 * gl_TessCoord.y + v2 * gl_TessCoord.z;
}

// Recreated ripple effect logic
vec3 applyRipple(vec3 position, vec3 normal) {
    if (ripple_enabled == 1 && ripple_strength > 0.0) {
        float ripple_speed = 5.0;
        float ripple_frequency = 10.0;
        float wave = sin(dot(position.xz, vec2(0.5, 0.5)) * ripple_frequency + time * ripple_speed) * ripple_strength;
        return position + normal * wave;
    }
    return position;
}

void main() {
	// 1. Interpolate per-vertex attributes from the control patch using barycentric coordinates
	vec3 p0 = WorldPos_TC_out[0];
	vec3 p1 = WorldPos_TC_out[1];
	vec3 p2 = WorldPos_TC_out[2];

	vec3 n0 = Normal_TC_out[0];
	vec3 n1 = Normal_TC_out[1];
	vec3 n2 = Normal_TC_out[2];

	// Linearly interpolated position (flat triangle)
	vec3 q = barycentric_interp(p0, p1, p2);

	// Linearly interpolated normal
	Normal = normalize(barycentric_interp(n0, n1, n2));

	// Interpolate texture coordinates
	TexCoords = barycentric_interp(TexCoords_TC_out[0], TexCoords_TC_out[1], TexCoords_TC_out[2]);

	// Interpolate color
	vs_color = barycentric_interp(Color_TC_out[0], Color_TC_out[1], Color_TC_out[2]);

	// 2. Phong Tessellation for smooth surfaces
	// Project the control points onto the tangent plane at the interpolated position 'q'
	vec3 p0_proj = p0 - dot(p0 - q, Normal) * Normal;
	vec3 p1_proj = p1 - dot(p1 - q, Normal) * Normal;
	vec3 p2_proj = p2 - dot(p2 - q, Normal) * Normal;

	// Interpolate the projected points to get the final smoothed position
	vec3 phong_pos = barycentric_interp(p0_proj, p1_proj, p2_proj);

	// Blend between flat and smoothed position
	vec3 final_pos = mix(q, phong_pos, uPhongAlpha);

	// 3. Apply vertex-displacement visual effects in world space
	final_pos = applyRipple(final_pos, Normal);
	final_pos = applyGlitch(final_pos, time);

	// Final world-space position for fragment shader
	FragPos = final_pos;

	// 4. Pass barycentric coordinates for wireframe effect
	barycentric = gl_TessCoord;

	// 5. Final projection to clip space
	gl_Position = projection * view * vec4(FragPos, 1.0);

	// 6. Set clip distance for planar reflections
	gl_ClipDistance[0] = dot(vec4(FragPos, 1.0), clipPlane);
}
