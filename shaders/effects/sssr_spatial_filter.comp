#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba16f) uniform writeonly image2D uOutImage;

uniform sampler2D uInputTexture;
uniform sampler2D uNormalTexture;
uniform sampler2D uDepthTexture;

float linearizeDepth(float d) {
    float z = d * 2.0 - 1.0;
    return (2.0 * 0.1 * 1000.0) / (1000.0 + 0.1 - z * (1000.0 - 0.1));
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = textureSize(uInputTexture, 0);

    if (pixel.x >= size.x || pixel.y >= size.y)
        return;

    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);

    vec3 centerNormal = texture(uNormalTexture, uv).xyz;
    float centerDepth = texture(uDepthTexture, uv).r;
    float centerLinDepth = linearizeDepth(centerDepth);

    vec4 sum = vec4(0.0);
    float totalWeight = 0.0;

    vec4 centerVal = texture(uInputTexture, uv);
    if (centerVal.a < 0.001) {
        imageStore(uOutImage, pixel, vec4(0.0));
        return;
    }
    float centerLum = dot(centerVal.rgb, vec3(0.2126, 0.7152, 0.0722));

    // Spatial filter with circular kernel and improved bilateral weights
    const int radius = 4;
    for (int y = -radius; y <= radius; y++) {
        for (int x = -radius; x <= radius; x++) {
            float distSq = float(x*x + y*y);
            if (distSq > float(radius * radius)) continue; // Circular kernel

            vec2 offset = vec2(x, y) / vec2(size);
            vec2 sampleUV = uv + offset;

            vec3 sampleNormal = texture(uNormalTexture, sampleUV).xyz;
            float sampleDepth = texture(uDepthTexture, sampleUV).r;
            float sampleLinDepth = linearizeDepth(sampleDepth);

            // Bilateral weights - increased normal power for sharper boundaries
            float spatialWeight = exp(-distSq / (2.0 * float(radius)));
            float normalWeight = pow(max(0.0, dot(centerNormal, sampleNormal)), 256.0);
            float depthWeight = exp(-abs(centerLinDepth - sampleLinDepth) * 20.0);

            vec4 val = texture(uInputTexture, sampleUV);
            if (any(isnan(val))) val = vec4(0.0);

            // Use the sample's reflection alpha (roughnessFade) to weight its contribution.
            // This prevents non-reflective neighbors from darkening the reflective center.
            float weight = spatialWeight * normalWeight * depthWeight * val.a;

            if (weight < 1e-6) continue;

            // Firefly rejection
            float sampleLum = dot(val.rgb, vec3(0.2126, 0.7152, 0.0722));
            if (sampleLum > centerLum * 10.0 + 1.0) {
                val.rgb *= (centerLum * 10.0 + 1.0) / sampleLum;
            }

            sum += val * weight;
            totalWeight += weight;
        }
    }

    vec4 result = sum / max(totalWeight, 0.0001);
    imageStore(uOutImage, pixel, result);
}
