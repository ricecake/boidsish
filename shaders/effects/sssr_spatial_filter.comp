#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba16f) uniform writeonly image2D uOutImage;

layout(binding = 1) uniform sampler2D uInputTexture;
layout(binding = 2) uniform sampler2D uNormalTexture;
layout(binding = 3) uniform sampler2D uDepthTexture;

float linearizeDepth(float d) {
    float z = d * 2.0 - 1.0;
    return (2.0 * 0.1 * 1000.0) / (1000.0 + 0.1 - z * (1000.0 - 0.1));
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = textureSize(uInputTexture, 0);

    if (pixel.x >= size.x || pixel.y >= size.y)
        return;

    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);

    vec3 centerNormal = texture(uNormalTexture, uv).xyz;
    float centerDepth = texture(uDepthTexture, uv).r;
    float centerLinDepth = linearizeDepth(centerDepth);

    vec4 sum = vec4(0.0);
    float totalWeight = 0.0;

    vec4 centerVal = texture(uInputTexture, uv);
    if (centerVal.a < 0.001) {
        imageStore(uOutImage, pixel, vec4(0.0));
        return;
    }
    float centerLum = dot(centerVal.rgb, vec3(0.2126, 0.7152, 0.0722));

    // Spatial filter with circular kernel and improved bilateral weights
    const int radius = 4;
    for (int y = -radius; y <= radius; y++) {
        for (int x = -radius; x <= radius; x++) {
            float distSq = float(x*x + y*y);
            if (distSq > float(radius * radius)) continue; // Circular kernel

            vec2 offset = vec2(x, y) / vec2(size);
            vec2 sampleUV = uv + offset;

            vec3 sampleNormal = texture(uNormalTexture, sampleUV).xyz;
            float sampleDepth = texture(uDepthTexture, sampleUV).r;
            float sampleLinDepth = linearizeDepth(sampleDepth);

            // Bilateral weights - adjusted normal power based on center roughness (alpha)
            float spatialWeight = exp(-distSq / (2.0 * float(radius)));
            float normalPower = mix(16.0, 128.0, centerVal.a);
            float normalWeight = pow(max(0.0, dot(centerNormal, sampleNormal)), normalPower);
            float depthWeight = exp(-abs(centerLinDepth - sampleLinDepth) * 10.0);

            vec4 val = texture(uInputTexture, sampleUV);
            if (any(isnan(val))) val = vec4(0.0);

            // Weight by neighbor's alpha to ensure they are also reflective
            float weight = spatialWeight * normalWeight * depthWeight * val.a;

            if (weight < 1e-6) continue;

            // Relaxed firefly rejection: use a wider clamp or Karis-like weighting
            float sampleLum = dot(val.rgb, vec3(0.2126, 0.7152, 0.0722));
            float maxLum = max(centerLum * 10.0, 2.0); // Allow more room for stochastic hits
            if (sampleLum > maxLum) {
                val.rgb *= (maxLum / sampleLum);
            }

            sum += val * weight;
            totalWeight += weight;
        }
    }

    vec4 result = sum / max(totalWeight, 0.0001);

    // Fallback if neighbors were too different: avoid black holes
    if (totalWeight < 0.01) {
        result = centerVal;
    }

    imageStore(uOutImage, pixel, result);
}
