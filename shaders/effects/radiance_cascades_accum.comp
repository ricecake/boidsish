#version 430 core
layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, rgba16f) uniform image2D outResult;

uniform sampler2DArray uCascadesTexture; // Use Cascade 0
uniform sampler2D uHistoryFrame;
uniform sampler2D uVelocity;
uniform sampler2D uDepth;

#include "temporal_data.glsl"

uniform float uAlpha = 0.9;

void main() {
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(outResult);
	if (pixel.x >= size.x || pixel.y >= size.y)
		return;

	vec2 uv = (vec2(pixel) + 0.5) / vec2(size);

	// 1. Average Cascade 0 rays (4 rays per pixel)
	ivec2 baseTexel = pixel * 2;
    vec3 currentGI = vec3(0.0);
    currentGI += texelFetch(uCascadesTexture, ivec3(baseTexel, 0), 0).rgb;
    currentGI += texelFetch(uCascadesTexture, ivec3(baseTexel + ivec2(1, 0), 0), 0).rgb;
    currentGI += texelFetch(uCascadesTexture, ivec3(baseTexel + ivec2(0, 1), 0), 0).rgb;
    currentGI += texelFetch(uCascadesTexture, ivec3(baseTexel + ivec2(1, 1), 0), 0).rgb;
    currentGI /= 4.0;

	// 2. Reprojection
	vec2 velocity = texture(uVelocity, uv).rg;
	vec2 prevUV = uv - velocity;

	if (prevUV.x < 0.0 || prevUV.x > 1.0 || prevUV.y < 0.0 || prevUV.y > 1.0) {
		imageStore(outResult, pixel, vec4(currentGI, 1.0));
		return;
	}

	vec4 history = texture(uHistoryFrame, prevUV);

	// 3. Neighborhood Clamping (Simplified 3x3)
    // We can't easily sample currentGI neighborhood without another pass or shared memory.
    // Let's use a looser clamping or skip it for GI if it's slow.
    // For GI, simple mixing is often okay if jitter is small.

	imageStore(outResult, pixel, mix(vec4(currentGI, 1.0), history, uAlpha));
}
