#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba16f) uniform writeonly image2D uOutRadiance;

uniform sampler2D uSceneTexture;
uniform sampler2D uHiZTexture;
uniform sampler2D uNormalTexture;
uniform sampler2D uMaterialTexture;

uniform mat4 uView;
uniform mat4 uProj;
uniform mat4 uInvView;
uniform mat4 uInvProj;
uniform vec3 uCameraPos;

uniform float uIntensity;
uniform int   uMaxSteps;
uniform float uRoughnessThreshold;
uniform int   uFrameCount;

#define PI 3.14159265359

// Hammersley Sequence
float radicalInverse_VdC(uint bits) {
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10;
}

vec2 hammersley(uint i, uint N) {
    return vec2(float(i) / float(N), radicalInverse_VdC(i));
}

uint hash(uint x) {
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = (x >> 16) ^ x;
    return x;
}

float GeometrySchlickGGX(float NdotV, float roughness) {
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    return GeometrySchlickGGX(NdotV, roughness) * GeometrySchlickGGX(NdotL, roughness);
}

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

vec3 importanceSampleGGX(vec2 xi, vec3 N, float roughness) {
    float a = roughness * roughness;
    float phi = 2.0 * PI * xi.x;
    float cosTheta = sqrt((1.0 - xi.y) / max(1.0 + (a * a - 1.0) * xi.y, 0.0001));
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));

    vec3 H;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;

    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    return normalize(tangent * H.x + bitangent * H.y + N * H.z);
}

bool is_bad(vec3 v) {
    return any(isnan(v)) || any(isinf(v));
}

float linearizeDepth(float d) {
    float z = d * 2.0 - 1.0;
    return (2.0 * 0.1 * 1000.0) / (1000.0 + 0.1 - z * (1000.0 - 0.1));
}

vec3 getSkyColor(vec3 worldRay) {
    vec3 twilight_color = vec3(0.9, 0.5, 0.2);
    vec3 mid_sky_color = vec3(0.2, 0.4, 0.8);
    vec3 top_sky_color = vec3(0.05, 0.1, 0.3);

    float y = clamp(worldRay.y, -1.0, 1.0);
    float atmosphere_thickness = exp(-abs(y) * 15.0);

    vec3 sky_base = mix(top_sky_color, mid_sky_color, atmosphere_thickness * 0.5);

    vec3 sun_dir = normalize(vec3(0.0, 0.1, -1.0));
    float sun_alignment = max(0.0, dot(worldRay, sun_dir));
    float glow = pow(sun_alignment, 8.0) * atmosphere_thickness;

    return mix(sky_base, twilight_color, glow);
}

// Hierarchical Z-Trace
bool hiZTrace(vec3 ro, vec3 rd, vec3 worldRay, out vec2 hitUV) {
    vec4 c0 = uProj * vec4(ro, 1.0);
    if (c0.w <= 0.0) return false;
    vec3 s0 = (c0.xyz / c0.w) * 0.5 + 0.5;

    vec3 pEnd = ro + rd * 100.0;
    vec4 c1 = uProj * vec4(pEnd, 1.0);
    if (c1.w <= 0.0) {
        float t = (0.1 - c0.w) / (c1.w - c0.w);
        pEnd = ro + rd * (100.0 * t);
        c1 = uProj * vec4(pEnd, 1.0);
    }
    vec3 s1 = (c1.xyz / c1.w) * 0.5 + 0.5;

    vec3 rayDir = s1 - s0;
    if (length(rayDir.xy) < 0.0001) return false;

    vec3 invRayDir = 1.0 / (rayDir + sign(rayDir) * 0.000001);

    int maxLevel = textureQueryLevels(uHiZTexture) - 1;
    int level = 0;

    vec3 p = s0 + normalize(rayDir) * 0.001;
    vec2 size = vec2(textureSize(uHiZTexture, 0));

    float thicknessLimit = 0.5; // World-space thickness limit

    for (int i = 0; i < uMaxSteps; i++) {
        if (any(lessThan(p, vec3(0.0))) || any(greaterThan(p, vec3(1.0)))) return false;

        float z = textureLod(uHiZTexture, p.xy, level).r;

        if (p.z > z + 0.00001) {
            if (level == 0) {
                float linP = linearizeDepth(p.z);
                float linZ = linearizeDepth(z);

                if (linP - linZ < thicknessLimit) {
                    // Potential hit, but check normal to avoid hitting backfaces
                    vec3 hitNormal = texture(uNormalTexture, p.xy).xyz;
                    if (dot(worldRay, hitNormal) < 0.0) {
                        hitUV = p.xy;
                        return true;
                    }
                }

                // If we are too far behind or it's a backface, skip forward
                p += rayDir * 0.005;
            } else {
                level--;
            }
        } else {
            vec2 cellCount = size / pow(2.0, float(level));
            vec2 cell = floor(p.xy * cellCount);
            vec2 boundary = (cell + step(0.0, rayDir.xy)) / cellCount;
            vec2 t = (boundary - p.xy) * invRayDir.xy;
            float tMin = min(t.x, t.y);

            p += rayDir * (tMin + 0.00001);
            level = min(maxLevel, level + 1);
        }
    }

    return false;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(uOutRadiance);
    if (pixel.x >= size.x || pixel.y >= size.y) return;

    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);
    vec3 worldNormal = texture(uNormalTexture, uv).xyz;
    if (length(worldNormal) < 0.1 || is_bad(worldNormal)) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }

    vec4 matData = texture(uMaterialTexture, uv);
    float roughness = matData.r;
    float roughnessFade = smoothstep(uRoughnessThreshold, uRoughnessThreshold * 0.9, roughness);
    if (roughnessFade <= 0.0 || isnan(roughness)) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }

    float depth = textureLod(uHiZTexture, uv, 0).r;
    if (isnan(depth) || depth >= 1.0) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }

    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 viewPos = uInvProj * clipPos;
    if (abs(viewPos.w) < 0.0001) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }
    viewPos /= viewPos.w;
    vec3 worldPos = (uInvView * viewPos).xyz;

    vec3 V = normalize(uCameraPos - worldPos);
    if (is_bad(V)) V = vec3(0, 1, 0);

    uint pixelIdx = uint(pixel.y * size.x + pixel.x);
    uint seed = hash(pixelIdx ^ hash(uint(uFrameCount)));
    const uint numSamples = 512;
    vec2 xi = hammersley(seed % numSamples, numSamples);

    vec3 L;
    vec3 H;
    float weight = 1.0;

    if (roughness < 0.02) {
        L = reflect(-V, worldNormal);
        H = worldNormal;
    } else {
        H = importanceSampleGGX(xi, worldNormal, roughness);
        L = reflect(-V, H);

        // Proper GGX weighting for importance sampling
        float NdotL = max(dot(worldNormal, L), 0.0);
        float NdotV = max(dot(worldNormal, V), 0.0);
        float NdotH = max(dot(worldNormal, H), 0.0);
        float VdotH = max(dot(V, H), 0.0);

        if (NdotL > 0.0) {
            float G = GeometrySmith(worldNormal, V, L, roughness);
            vec3 F0 = mix(vec3(0.04), texture(uSceneTexture, uv).rgb, matData.g); // Approximate F0
            vec3 F = fresnelSchlick(VdotH, F0);

            // Weight = (F * G * VdotH) / (NdotV * NdotH)
            vec3 w = (F * G * VdotH) / max(NdotV * NdotH, 0.0001);
            weight = clamp(length(w), 0.0, 2.0); // Clamp weight to avoid fireflies
        } else {
            weight = 0.0;
        }
    }

    if (is_bad(L)) L = reflect(-V, worldNormal);

    vec3 viewNormal = normalize(mat3(uView) * worldNormal);
    vec3 ro = viewPos.xyz + viewNormal * 0.05;
    vec3 rd = normalize((uView * vec4(L, 0.0)).xyz);

    vec2 hitUV;
    bool hit = hiZTrace(ro, rd, L, hitUV);

    vec4 radiance = vec4(0.0);
    if (hit) {
        vec3 reflectedColor = texture(uSceneTexture, hitUV).rgb;
        if (any(isnan(reflectedColor))) reflectedColor = vec3(0.0);

        // Luminance clamping to reduce speckling (Fire/Bright spots)
        float lum = dot(reflectedColor, vec3(0.2126, 0.7152, 0.0722));
        if (lum > 10.0) reflectedColor *= (10.0 / lum);

        vec2 dUV = abs(hitUV - 0.5) * 2.0;
        float edgeFade = 1.0 - max(smoothstep(0.8, 1.0, dUV.x), smoothstep(0.8, 1.0, dUV.y));

        radiance.rgb = mix(getSkyColor(L), reflectedColor, edgeFade);
        radiance.a = 1.0;
    } else {
        radiance.rgb = getSkyColor(L);
        radiance.a = 1.0;
    }

    radiance.rgb = clamp(radiance.rgb, vec3(0.0), vec3(10.0));
    if (is_bad(radiance.rgb)) radiance.rgb = vec3(0.0);

    imageStore(uOutRadiance, pixel, radiance * uIntensity * roughnessFade * weight);
}
