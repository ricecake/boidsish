#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba16f) uniform writeonly image2D uOutRadiance;

uniform sampler2D uSceneTexture;
uniform sampler2D uHiZTexture;
uniform sampler2D uNormalTexture;
uniform sampler2D uMaterialTexture;

uniform mat4 uView;
uniform mat4 uProj;
uniform mat4 uInvView;
uniform mat4 uInvProj;
uniform vec3 uCameraPos;

uniform float uIntensity;
uniform int   uMaxSteps;
uniform float uRoughnessThreshold;
uniform int   uFrameCount;

#define PI 3.14159265359

// Hammersley Sequence
float radicalInverse_VdC(uint bits) {
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10;
}

vec2 hammersley(uint i, uint N) {
    return vec2(float(i) / float(N), radicalInverse_VdC(i));
}

vec3 importanceSampleGGX(vec2 xi, vec3 N, float roughness) {
    float a = roughness * roughness;
    float phi = 2.0 * PI * xi.x;
    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));

    vec3 H;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;

    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    return normalize(tangent * H.x + bitangent * H.y + N * H.z);
}

vec3 getSkyColor(vec3 worldRay) {
    // Gradient Sky
    vec3 bottom = vec3(0.05, 0.1, 0.3);
    vec3 top = vec3(0.0, 0.0, 0.1);
    vec3 sunset = vec3(0.9, 0.5, 0.2);

    float y = worldRay.y;
    vec3 col = mix(bottom, top, smoothstep(0.0, 1.0, y));

    vec3 sunDir = normalize(vec3(0.0, 0.1, -1.0));
    float sun = pow(max(0.0, dot(worldRay, sunDir)), 16.0);
    col += sunset * sun;

    return col;
}

// Hierarchical Z-Trace
bool hiZTrace(vec3 ro, vec3 rd, out vec2 hitUV) {
    vec4 c0 = uProj * vec4(ro, 1.0);
    vec3 s0 = (c0.xyz / c0.w) * 0.5 + 0.5;

    vec4 c1 = uProj * vec4(ro + rd, 1.0);
    vec3 s1 = (c1.xyz / c1.w) * 0.5 + 0.5;

    vec3 rayDir = normalize(s1 - s0);
    vec3 invRayDir = 1.0 / rayDir;

    int maxLevel = textureQueryLevels(uHiZTexture) - 1;
    int level = 0;

    vec3 p = s0;
    vec2 size = vec2(textureSize(uHiZTexture, 0));

    for (int i = 0; i < uMaxSteps; i++) {
        if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0 || p.z < 0.0 || p.z > 1.0) return false;

        float z = textureLod(uHiZTexture, p.xy, level).r;

        if (p.z > z + 0.00001) {
            if (level == 0) {
                // Precise intersection
                hitUV = p.xy;
                // Thickness check
                if (p.z - z < 0.005) return true;
                // skip
                p += rayDir * 0.005;
            } else {
                level--;
            }
        } else {
            // Advance to next cell
            vec2 cellCount = size / pow(2.0, float(level));
            vec2 cell = floor(p.xy * cellCount);
            vec2 boundary = (cell + step(0.0, rayDir.xy)) / cellCount;
            vec2 t = (boundary - p.xy) * invRayDir.xy;
            float tMin = min(t.x, t.y);

            p += rayDir * (tMin + 0.0001);
            level = min(maxLevel, level + 1);
        }
    }

    return false;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(uOutRadiance);
    if (pixel.x >= size.x || pixel.y >= size.y) return;

    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);
    vec3 worldNormal = texture(uNormalTexture, uv).xyz;
    if (length(worldNormal) < 0.1) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }

    vec4 matData = texture(uMaterialTexture, uv);
    float roughness = matData.r;
    if (roughness > uRoughnessThreshold) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }

    float depth = textureLod(uHiZTexture, uv, 0).r;
    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 viewPos = uInvProj * clipPos;
    viewPos /= viewPos.w;
    vec3 worldPos = (uInvView * viewPos).xyz;

    vec3 V = normalize(uCameraPos - worldPos);
    vec2 xi = hammersley(uint(uFrameCount) % 64u, 64u);

    vec3 L;
    if (roughness < 0.02) {
        L = reflect(-V, worldNormal);
    } else {
        vec3 H = importanceSampleGGX(xi, worldNormal, roughness);
        L = reflect(-V, H);
    }

    vec3 ro = viewPos.xyz;
    vec3 rd = (uView * vec4(L, 0.0)).xyz;

    vec2 hitUV;
    bool hit = hiZTrace(ro, rd, hitUV);

    vec4 radiance = vec4(0.0);
    if (hit) {
        vec3 reflectedColor = texture(uSceneTexture, hitUV).rgb;

        // Edge fade to smoothly transition to skybox
        vec2 dUV = abs(hitUV - 0.5) * 2.0;
        float edgeFade = 1.0 - max(smoothstep(0.8, 1.0, dUV.x), smoothstep(0.8, 1.0, dUV.y));

        radiance.rgb = mix(getSkyColor(L), reflectedColor, edgeFade);
        radiance.a = 1.0;
    } else {
        radiance.rgb = getSkyColor(L);
        radiance.a = 1.0;
    }

    imageStore(uOutRadiance, pixel, radiance * uIntensity);
}
