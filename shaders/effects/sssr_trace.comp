#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba16f) uniform writeonly image2D uOutRadiance;

uniform sampler2D uSceneTexture;
uniform sampler2D uHiZTexture;
uniform sampler2D uNormalTexture;
uniform sampler2D uMaterialTexture;

uniform mat4 uView;
uniform mat4 uProj;
uniform mat4 uInvView;
uniform mat4 uInvProj;
uniform vec3 uCameraPos;

uniform float uIntensity;
uniform int   uMaxSteps;
uniform float uRoughnessThreshold;
uniform int   uFrameCount;

#define PI 3.14159265359

// Hammersley Sequence
float radicalInverse_VdC(uint bits) {
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10;
}

vec2 hammersley(uint i, uint N) {
    return vec2(float(i) / float(N), radicalInverse_VdC(i));
}

vec3 importanceSampleGGX(vec2 xi, vec3 N, float roughness) {
    float a = roughness * roughness;
    float phi = 2.0 * PI * xi.x;
    float cosTheta = sqrt((1.0 - xi.y) / max(1.0 + (a * a - 1.0) * xi.y, 0.0001));
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));

    vec3 H;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;

    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    return normalize(tangent * H.x + bitangent * H.y + N * H.z);
}

bool is_bad(vec3 v) {
    return any(isnan(v)) || any(isinf(v));
}

vec3 getSkyColor(vec3 worldRay) {
    vec3 twilight_color = vec3(0.9, 0.5, 0.2);
    vec3 mid_sky_color = vec3(0.2, 0.4, 0.8);
    vec3 top_sky_color = vec3(0.05, 0.1, 0.3);

    float y = clamp(worldRay.y, -1.0, 1.0);
    float atmosphere_thickness = exp(-abs(y) * 15.0);

    vec3 sky_base = mix(top_sky_color, mid_sky_color, atmosphere_thickness * 0.5);

    vec3 sun_dir = normalize(vec3(0.0, 0.1, -1.0));
    float sun_alignment = max(0.0, dot(worldRay, sun_dir));
    float glow = pow(sun_alignment, 8.0) * atmosphere_thickness;

    return mix(sky_base, twilight_color, glow);
}

// Hierarchical Z-Trace with improved precision and bias
bool hiZTrace(vec3 ro, vec3 rd, out vec2 hitUV) {
    vec4 c0 = uProj * vec4(ro, 1.0);
    if (c0.w <= 0.0) return false;
    vec3 s0 = (c0.xyz / c0.w) * 0.5 + 0.5;

    // Determine end point based on scene bounds
    vec3 pEnd = ro + rd * 100.0;
    vec4 c1 = uProj * vec4(pEnd, 1.0);
    if (c1.w <= 0.0) {
        // Ray goes behind camera, clip it to near plane
        float t = (0.1 - c0.w) / (c1.w - c0.w);
        pEnd = ro + rd * (100.0 * t);
        c1 = uProj * vec4(pEnd, 1.0);
    }
    vec3 s1 = (c1.xyz / c1.w) * 0.5 + 0.5;

    vec3 rayDir = s1 - s0;
    if (length(rayDir.xy) < 0.0001) return false;

    vec3 invRayDir = 1.0 / (rayDir + sign(rayDir) * 0.000001);

    int maxLevel = textureQueryLevels(uHiZTexture) - 1;
    int level = 0;

    // Start with a small bias to avoid self-intersection
    vec3 p = s0 + normalize(rayDir) * 0.001;
    vec2 size = vec2(textureSize(uHiZTexture, 0));

    // Dynamic thickness based on depth
    float minThickness = 0.001;
    float maxThickness = 0.05;

    for (int i = 0; i < uMaxSteps; i++) {
        if (any(lessThan(p, vec3(0.0))) || any(greaterThan(p, vec3(1.0)))) return false;

        float z = textureLod(uHiZTexture, p.xy, level).r;

        // standard GL depth: p.z > z means p is behind the surface
        if (p.z > z + 0.00001) {
            if (level == 0) {
                hitUV = p.xy;
                // Refined thickness check: prevent leaking through thin objects
                // but ensure we hit solid ones.
                float thickness = mix(minThickness, maxThickness, p.z);
                if (p.z - z < thickness) return true;

                // If it's too thick, it's an occlusion, skip this cell
                p += rayDir * 0.002;
            } else {
                level--;
            }
        } else {
            // Advance to next cell boundary at current level
            vec2 cellCount = size / pow(2.0, float(level));
            vec2 cell = floor(p.xy * cellCount);
            vec2 boundary = (cell + step(0.0, rayDir.xy)) / cellCount;
            vec2 t = (boundary - p.xy) * invRayDir.xy;
            float tMin = min(t.x, t.y);

            p += rayDir * (tMin + 0.00001);
            level = min(maxLevel, level + 1);
        }
    }

    return false;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(uOutRadiance);
    if (pixel.x >= size.x || pixel.y >= size.y) return;

    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);
    vec3 worldNormal = texture(uNormalTexture, uv).xyz;
    if (length(worldNormal) < 0.1 || is_bad(worldNormal)) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }

    vec4 matData = texture(uMaterialTexture, uv);
    float roughness = matData.r;
    float roughnessFade = smoothstep(uRoughnessThreshold, uRoughnessThreshold * 0.9, roughness);
    if (roughnessFade <= 0.0 || isnan(roughness)) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }

    float depth = textureLod(uHiZTexture, uv, 0).r;
    if (isnan(depth) || depth >= 1.0) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }

    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 viewPos = uInvProj * clipPos;
    if (abs(viewPos.w) < 0.0001) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }
    viewPos /= viewPos.w;
    vec3 worldPos = (uInvView * viewPos).xyz;

    vec3 V = normalize(uCameraPos - worldPos);
    if (is_bad(V)) V = vec3(0, 1, 0);

    vec2 xi = hammersley(uint(uFrameCount) % 64u, 64u);

    vec3 L;
    if (roughness < 0.02) {
        L = reflect(-V, worldNormal);
    } else {
        vec3 H = importanceSampleGGX(xi, worldNormal, roughness);
        L = reflect(-V, H);
    }

    if (is_bad(L)) L = reflect(-V, worldNormal);

    // Trace in View Space
    // Bias the origin along the normal to avoid self-intersection
    vec3 viewNormal = normalize(mat3(uView) * worldNormal);
    vec3 ro = viewPos.xyz + viewNormal * 0.05;
    vec3 rd = normalize((uView * vec4(L, 0.0)).xyz);

    vec2 hitUV;
    bool hit = hiZTrace(ro, rd, hitUV);

    vec4 radiance = vec4(0.0);
    if (hit) {
        vec3 reflectedColor = texture(uSceneTexture, hitUV).rgb;
        if (any(isnan(reflectedColor))) reflectedColor = vec3(0.0);

        vec2 dUV = abs(hitUV - 0.5) * 2.0;
        float edgeFade = 1.0 - max(smoothstep(0.8, 1.0, dUV.x), smoothstep(0.8, 1.0, dUV.y));

        radiance.rgb = mix(getSkyColor(L), reflectedColor, edgeFade);
        radiance.a = 1.0;
    } else {
        radiance.rgb = getSkyColor(L);
        radiance.a = 1.0;
    }

    radiance.rgb = clamp(radiance.rgb, vec3(0.0), vec3(100.0));
    imageStore(uOutRadiance, pixel, radiance * uIntensity * roughnessFade);
}
