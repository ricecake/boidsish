#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba16f) uniform writeonly image2D uOutRadiance;

// Sampler bindings
layout(binding = 1) uniform sampler2D uSceneTexture;
layout(binding = 2) uniform sampler2D uHiZTexture;
layout(binding = 3) uniform sampler2D uNormalTexture;
layout(binding = 4) uniform sampler2D uMaterialTexture;
uniform mat4 uView;
uniform mat4 uProj;
uniform mat4 uInvView;
uniform mat4 uInvProj;
uniform vec3 uCameraPos;

uniform float uIntensity;
uniform int   uMaxSteps;
uniform float uRoughnessThreshold;
uniform int   uFrameCount;
uniform int   uNumMips;

struct Light {
	vec3  position;
	float intensity;
	vec3  color;
	int   type;
	vec3  direction;
	float inner_cutoff;
	float outer_cutoff;
};

layout(std140, binding = 0) uniform Lighting {
	Light lights[10];
	int   num_lights;
	float worldScale;
	float dayTime;
	float nightFactor;
	vec3  viewPos;
	vec3  ambient_light;
	float time;
	vec3  viewDir;
};

#define PI 3.14159265359

// Hammersley Sequence
float radicalInverse_VdC(uint bits) {
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10;
}

vec2 hammersley(uint i, uint N) {
    return vec2(float(i) / float(N), radicalInverse_VdC(i));
}

uint hash(uint x) {
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = ((x >> 16) ^ x) * 0x45d9f3b;
    x = (x >> 16) ^ x;
    return x;
}

float GeometrySchlickGGX(float NdotV, float roughness) {
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    return GeometrySchlickGGX(NdotV, roughness) * GeometrySchlickGGX(NdotL, roughness);
}

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

vec3 importanceSampleGGX(vec2 xi, vec3 N, float roughness) {
    float a = roughness * roughness;
    float phi = 2.0 * PI * xi.x;
    float cosTheta = sqrt((1.0 - xi.y) / max(1.0 + (a * a - 1.0) * xi.y, 0.0001));
    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));

    vec3 H;
    H.x = cos(phi) * sinTheta;
    H.y = sin(phi) * sinTheta;
    H.z = cosTheta;

    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    return normalize(tangent * H.x + bitangent * H.y + N * H.z);
}

bool is_bad(vec3 v) {
    return any(isnan(v)) || any(isinf(v));
}

float linearizeDepth(float d) {
    float z = d * 2.0 - 1.0;
    return (2.0 * 0.1 * 1000.0) / (1000.0 + 0.1 - z * (1000.0 - 0.1));
}

vec3 getSkyColor(vec3 worldRay) {
    vec3 twilight_color = vec3(0.9, 0.5, 0.2);
    vec3 mid_sky_color = vec3(0.2, 0.4, 0.8);
    vec3 top_sky_color = vec3(0.05, 0.1, 0.3);

    float y = clamp(worldRay.y, -1.0, 1.0);
    float atmosphere_thickness = exp(-abs(y) * 15.0);

    vec3 sky_base = mix(top_sky_color, mid_sky_color, atmosphere_thickness * 0.5);

    // Use actual sun direction if available (usually first light is directional)
    vec3 sun_dir = normalize(vec3(0.0, 0.1, -1.0));
    if (num_lights > 0 && lights[0].type == 1) {
        sun_dir = -normalize(lights[0].direction);
    }

    float sun_alignment = max(0.0, dot(worldRay, sun_dir));
    float glow = pow(sun_alignment, 8.0) * atmosphere_thickness;

    vec3 sky = mix(sky_base, twilight_color, glow);

    // Dim sky at night
    return sky * (1.0 - nightFactor * 0.95);
}

// Hierarchical Z-Trace
bool hiZTrace(vec3 ro, vec3 rd, vec3 worldRay, out vec2 hitUV) {
    vec4 c0 = uProj * vec4(ro, 1.0);
    if (c0.w <= 0.0) return false;
    vec3 s0 = (c0.xyz / c0.w) * 0.5 + 0.5;

    s0 = clamp(s0, vec3(0.0), vec3(1.0));

    // We want to step until we hit something or leave the screen
    vec3 pEnd = ro + rd * 100.0;
    vec4 c1 = uProj * vec4(pEnd, 1.0);
    if (c1.w <= 0.0) {
        float t = (0.1 - c0.w) / (min(-0.001, c1.w - c0.w));
        pEnd = ro + rd * (100.0 * t);
        c1 = uProj * vec4(pEnd, 1.0);
    }
    vec3 s1 = (c1.xyz / c1.w) * 0.5 + 0.5;

    vec3 rayDir = s1 - s0;
    if (length(rayDir.xy) < 0.0001) return false;

    vec3 invRayDir = 1.0 / (rayDir + sign(rayDir) * 1e-9);

    int maxLevel = uNumMips - 1;
    int level = 0;

    // Use an epsilon scaled by resolution for boundary jumps
    vec2 size = vec2(textureSize(uHiZTexture, 0));
    vec2 eps = 0.001 / size;

    // Use a small offset to escape the starting surface
    vec3 p = s0 + rayDir * 0.0001;

    // Thickness limit should be small to avoid bleed-through
    float baseThickness = 0.05;

    for (int i = 0; i < uMaxSteps; i++) {
        if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0 || p.z < 0.0 || p.z > 1.0) return false;

        float z = textureLod(uHiZTexture, p.xy, level).r;

        if (p.z > z) {
            if (level == 0) {
                float linP = linearizeDepth(p.z);
                float linZ = linearizeDepth(z);
                float thicknessLimit = baseThickness * (1.0 + linZ * 0.01);

                if (linP - linZ < thicknessLimit) {
                    vec3 hitNormal = texture(uNormalTexture, p.xy).xyz;
                    if (dot(worldRay, hitNormal) < 0.0) {
                        hitUV = p.xy;
                        return true;
                    }
                }
                // Skip this cell: jump to boundary to avoid infinite loops or skipping too much
                vec2 cellCount = size; // level 0
                vec2 cell = floor(p.xy * cellCount);
                vec2 boundary = (cell + step(0.0, rayDir.xy)) / cellCount;
                vec2 t = (boundary - p.xy) * invRayDir.xy;
                float tMin = min(t.x, t.y);
                p += rayDir * (tMin + eps.x);
            } else {
                level--;
            }
        } else {
            // Jump to next cell boundary
            vec2 cellCount = size / pow(2.0, float(level));
            vec2 cell = floor(p.xy * cellCount);
            vec2 boundary = (cell + step(0.0, rayDir.xy)) / cellCount;
            vec2 t = (boundary - p.xy) * invRayDir.xy;
            float tMin = min(t.x, t.y);

            // Robust skip: only jump if the ray is also in front of the geometry at the cell exit
            float exitZ = p.z + rayDir.z * tMin;
            if (level == 0 || exitZ < z || (rayDir.z <= 0.0)) {
                p += rayDir * (tMin + eps.x);
                level = min(maxLevel, level + 1);
            } else {
                // Ray might intersect in this cell, descend
                level--;
            }
        }
    }

    return false;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(uOutRadiance);
    if (pixel.x >= size.x || pixel.y >= size.y) return;

    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);
    vec3 worldNormal = texture(uNormalTexture, uv).xyz;
    if (length(worldNormal) < 0.1 || is_bad(worldNormal)) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }

    vec4 matData = texture(uMaterialTexture, uv);
    float roughness = matData.r;
    float roughnessFade = smoothstep(uRoughnessThreshold, uRoughnessThreshold * 0.9, roughness);
    if (roughnessFade <= 0.0 || isnan(roughness)) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }

    float depth = textureLod(uHiZTexture, uv, 0).r;
    if (isnan(depth) || depth >= 1.0) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }

    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 viewPos = uInvProj * clipPos;
    if (abs(viewPos.w) < 0.0001) {
        imageStore(uOutRadiance, pixel, vec4(0.0));
        return;
    }
    viewPos /= viewPos.w;
    vec3 worldPos = (uInvView * viewPos).xyz;

    vec3 V = normalize(uCameraPos - worldPos);
    if (is_bad(V)) V = vec3(0, 1, 0);

    const uint numSamples = 512;
    // Walk through Hammersley sequence using frame count for temporal stability
    // but still jitter slightly per-pixel to avoid patterns
    uint frameSample = uint(uFrameCount) % numSamples;
    uint pixelIdx = uint(pixel.y * size.x + pixel.x);
    vec2 xi = hammersley((frameSample + hash(pixelIdx)) % numSamples, numSamples);

    vec3 L;
    vec3 H;
    vec3 weight = vec3(1.0);

    if (roughness < 0.02) {
        L = reflect(-V, worldNormal);
        H = worldNormal;
    } else {
        H = importanceSampleGGX(xi, worldNormal, roughness);
        L = reflect(-V, H);

        // Proper GGX weighting for importance sampling
        float NdotL = max(dot(worldNormal, L), 0.0);
        float NdotV = max(dot(worldNormal, V), 0.0);
        float NdotH = max(dot(worldNormal, H), 0.0);
        float VdotH = max(dot(V, H), 0.0);

        if (NdotL > 0.0) {
            float G = GeometrySmith(worldNormal, V, L, roughness);
            vec3 F0 = mix(vec3(0.04), texture(uSceneTexture, uv).rgb, matData.g); // Approximate F0
            vec3 F = fresnelSchlick(VdotH, F0);

            // Weight = (F * G * VdotH) / (NdotV * NdotH)
            weight = (F * G * VdotH) / max(NdotV * NdotH, 0.0001);

            // Graceful clamping to avoid fireflies while preserving color
            float maxW = max(weight.r, max(weight.g, weight.b));
            if (maxW > 2.0) {
                weight *= (2.0 / maxW);
            }
        } else {
            weight = vec3(0.0);
        }
    }

    if (is_bad(L)) L = reflect(-V, worldNormal);

    vec3 viewNormal = normalize(mat3(uView) * worldNormal);
    vec3 ro = viewPos.xyz + viewNormal * 0.05;
    vec3 rd = normalize((uView * vec4(L, 0.0)).xyz);

    vec2 hitUV;
    bool hit = hiZTrace(ro, rd, L, hitUV);

    vec4 radiance = vec4(0.0);
    if (hit) {
        vec3 reflectedColor = texture(uSceneTexture, hitUV).rgb;
        if (any(isnan(reflectedColor))) reflectedColor = vec3(0.0);

        // Luminance clamping to reduce speckling (Fire/Bright spots)
        float lum = dot(reflectedColor, vec3(0.2126, 0.7152, 0.0722));
        if (lum > 10.0) reflectedColor *= (10.0 / lum);

        vec2 dUV = abs(hitUV - 0.5) * 2.0;
        float edgeFade = 1.0 - max(smoothstep(0.8, 1.0, dUV.x), smoothstep(0.8, 1.0, dUV.y));

        radiance.rgb = mix(getSkyColor(L), reflectedColor, edgeFade);
        radiance.a = 1.0;
    } else {
        radiance.rgb = getSkyColor(L);
        radiance.a = 1.0;
    }

    radiance.rgb = clamp(radiance.rgb, vec3(0.0), vec3(10.0));
    if (is_bad(radiance.rgb)) radiance.rgb = vec3(0.0);

    // Weight color by Fresnel (already in weight) and Intensity
    vec3 finalRadiance = radiance.rgb * uIntensity * roughnessFade * weight;

    // Store radiance in RGB and roughnessFade in Alpha for use as a mask in filters
    imageStore(uOutRadiance, pixel, vec4(finalRadiance, roughnessFade));
}
