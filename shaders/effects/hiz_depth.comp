#version 430 core

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0) uniform sampler2D u_InputDepth;
layout(binding = 1, r32f) uniform writeonly image2D u_OutputMip;

uniform int u_Mode; // 0: Copy level 0, 1: Downsample
uniform int u_SrcLevel;
uniform vec2 u_DestSize;

void main() {
    ivec2 dstPos = ivec2(gl_GlobalInvocationID.xy);
    if (dstPos.x >= int(u_DestSize.x) || dstPos.y >= int(u_DestSize.y)) return;

    if (u_Mode == 0) {
        // Just copy depth from level 0
        float d = texelFetch(u_InputDepth, dstPos, 0).r;
        imageStore(u_OutputMip, dstPos, vec4(d));
    } else {
        // Downsample from u_SrcLevel to u_SrcLevel + 1
        ivec2 srcPos = dstPos * 2;

        float d00 = texelFetch(u_InputDepth, srcPos + ivec2(0, 0), u_SrcLevel).r;
        float d10 = texelFetch(u_InputDepth, srcPos + ivec2(1, 0), u_SrcLevel).r;
        float d01 = texelFetch(u_InputDepth, srcPos + ivec2(0, 1), u_SrcLevel).r;
        float d11 = texelFetch(u_InputDepth, srcPos + ivec2(1, 1), u_SrcLevel).r;

        // Use MIN depth for conservative ray marching (closest point in 2x2 area)
        float minDepth = min(min(d00, d10), min(d01, d11));
        imageStore(u_OutputMip, dstPos, vec4(minDepth));
    }
}
