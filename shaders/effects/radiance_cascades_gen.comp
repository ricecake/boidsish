#version 430 core

layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba16f, binding = 0) uniform image2DArray uCascadesTexture;

uniform sampler2D uSceneTexture;
uniform sampler2D uDepthTexture;
uniform sampler2D uHizTexture;

uniform int uCascadeIndex;
uniform vec2 uResolution;
uniform int uMaxSteps;
uniform bool uEnableHiZ;

#include "helpers/lighting.glsl"
#include "temporal_data.glsl"

float getLinearDepth(float depth) {
    float near = uProjection[3][2] / (uProjection[2][2] - 1.0);
    float far = uProjection[3][2] / (uProjection[2][2] + 1.0);
    float z = depth * 2.0 - 1.0;
    return (2.0 * near * far) / (far + near - z * (far - near));
}

float hash12(vec2 p) {
	vec3 p3 = fract(vec3(p.xyx) * .1031);
	p3 += dot(p3, p3.yzx + 33.33);
	return fract((p3.x + p3.y) * p3.z);
}

void main() {
    ivec3 texelPos = ivec3(gl_GlobalInvocationID.xyz);
    if (texelPos.x >= int(uResolution.x * 2) || texelPos.y >= int(uResolution.y * 2)) return;

    int n = uCascadeIndex;
    int raysPerSide = 1 << (n + 1);

    ivec2 probePos = texelPos.xy / raysPerSide;
    ivec2 rayIdx = texelPos.xy % raysPerSide;

    int linearRayIdx = rayIdx.y * raysPerSide + rayIdx.x;
    int numRays = raysPerSide * raysPerSide;

    // Ray jittering
    float jitter = hash12(vec2(probePos) + float(frameIndex) * 0.123);
    float angle = 2.0 * 3.14159265 * (float(linearRayIdx) + jitter) / float(numRays);
    vec2 rayDir = vec2(cos(angle), sin(angle));

    // Probe center in pixel coordinates
    vec2 probePixelPos;
    if (n == 0) probePixelPos = vec2(probePos) + 0.5;
    else probePixelPos = (vec2(probePos) + 0.5) * (1 << n);

    vec2 uv = probePixelPos / uResolution;
    float centerDepth = texture(uDepthTexture, uv).r;

    if (centerDepth >= 0.999) {
        imageStore(uCascadesTexture, ivec3(texelPos.xy, uCascadeIndex), vec4(0.0));
        return;
    }

    float linCenterDepth = getLinearDepth(centerDepth);

    // Raymarching range for this cascade
    float startDist = (n == 0) ? 1.0 : pow(4.0, float(n)) * 2.0;
    float endDist = pow(4.0, float(n + 1)) * 2.0;

    vec3 accumulatedRadiance = vec3(0.0);
    float hitOccurred = 0.0;

    float currentDist = startDist;
    int steps = uMaxSteps;

    // Hierarchical Raymarching / Variable Step Raymarching
    for (int i = 0; i < steps; ++i) {
        vec2 samplePos = probePixelPos + rayDir * currentDist;

        if (samplePos.x < 0 || samplePos.x >= uResolution.x || samplePos.y < 0 || samplePos.y >= uResolution.y) {
            break;
        }

        vec2 sampleUV = samplePos / uResolution;

        float stepSize = (endDist - startDist) / float(steps);

        if (uEnableHiZ) {
            // Use Hi-Z to potentially skip larger areas
            // Select mip level based on current step size or distance
            int mip = clamp(int(log2(currentDist * 0.1)), 0, 4);
            float minDepth = textureLod(uHizTexture, sampleUV, mip).r;
            float linMinDepth = getLinearDepth(minDepth);

            // If ray is in front of minimum depth in this area, we can skip
            if (linCenterDepth < linMinDepth - 1.0) {
                currentDist += stepSize * (1 << mip);
                continue;
            }
        }

        float sampleDepth = texture(uDepthTexture, sampleUV).r;
        float linSampleDepth = getLinearDepth(sampleDepth);

        float thickness = 2.0 * (1 << n) + currentDist * 0.05;
        if (linSampleDepth < linCenterDepth && linSampleDepth > linCenterDepth - thickness) {
            accumulatedRadiance = texture(uSceneTexture, sampleUV).rgb;
            hitOccurred = 1.0;
            break;
        }

        currentDist += stepSize;
        if (currentDist > endDist) break;
    }

    if (hitOccurred == 0.0) {
        vec3 skyColor = vec3(0.1, 0.2, 0.3) * nightFactor + vec3(0.5, 0.7, 1.0) * (1.0 - nightFactor);
        accumulatedRadiance = skyColor * 0.05;
    }

    imageStore(uCascadesTexture, ivec3(texelPos.xy, uCascadeIndex), vec4(accumulatedRadiance, hitOccurred));
}
