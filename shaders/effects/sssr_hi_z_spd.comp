#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, r32f) uniform writeonly image2D uHiZMips[12];
uniform sampler2D uDepthTexture;
uniform int uNumMips;

layout(binding = 1, std430) buffer GlobalCounter {
    uint uCounter[12];
};

shared float s_mipData[16][16];

void storeMip(float d, ivec2 coord, int level) {
    if (level < uNumMips && !isnan(d) && !isinf(d)) {
        imageStore(uHiZMips[level], coord, vec4(d));
    }
}

float reduce(float d0, float d1, float d2, float d3) {
    float m = 1.0;
    if (!isnan(d0) && !isinf(d0)) m = min(m, d0);
    if (!isnan(d1) && !isinf(d1)) m = min(m, d1);
    if (!isnan(d2) && !isinf(d2)) m = min(m, d2);
    if (!isnan(d3) && !isinf(d3)) m = min(m, d3);
    return m;
}

void main() {
    ivec2 gID = ivec2(gl_GlobalInvocationID.xy);
    ivec2 lID = ivec2(gl_LocalInvocationID.xy);
    ivec2 wID = ivec2(gl_WorkGroupID.xy);

    vec2 srcSize = vec2(textureSize(uDepthTexture, 0));
    vec2 uv = (vec2(gID * 2) + 1.0) / srcSize;

    float d0 = textureOffset(uDepthTexture, uv, ivec2(0, 0)).r;
    float d1 = textureOffset(uDepthTexture, uv, ivec2(1, 0)).r;
    float d2 = textureOffset(uDepthTexture, uv, ivec2(0, 1)).r;
    float d3 = textureOffset(uDepthTexture, uv, ivec2(1, 1)).r;

    float d = reduce(d0, d1, d2, d3);
    storeMip(d, gID, 1);

    s_mipData[lID.x][lID.y] = d;
    barrier();

    if (all(equal(lID % 2, ivec2(0)))) {
        d = reduce(s_mipData[lID.x][lID.y], s_mipData[lID.x+1][lID.y],
                   s_mipData[lID.x][lID.y+1], s_mipData[lID.x+1][lID.y+1]);
        s_mipData[lID.x][lID.y] = d;
        storeMip(d, gID / 2, 2);
    }
    barrier();

    if (all(equal(lID % 4, ivec2(0)))) {
        d = reduce(s_mipData[lID.x][lID.y], s_mipData[lID.x+2][lID.y],
                   s_mipData[lID.x][lID.y+2], s_mipData[lID.x+2][lID.y+2]);
        s_mipData[lID.x][lID.y] = d;
        storeMip(d, gID / 4, 3);
    }
    barrier();

    if (all(equal(lID % 8, ivec2(0)))) {
        d = reduce(s_mipData[lID.x][lID.y], s_mipData[lID.x+4][lID.y],
                   s_mipData[lID.x][lID.y+4], s_mipData[lID.x+4][lID.y+4]);
        s_mipData[lID.x][lID.y] = d;
        storeMip(d, gID / 8, 4);
    }
    barrier();

    if (lID == ivec2(0)) {
        d = reduce(s_mipData[0][0], s_mipData[8][0],
                   s_mipData[0][8], s_mipData[8][8]);
        storeMip(d, wID, 5);
    }
}
