#version 430 core
layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, rgba16f) uniform image2D outAO;

uniform sampler2D gDepth;
uniform sampler2D gColor;
// uniform sampler2D gNormal; // Reconstructing for now

#include "temporal_data.glsl"

uniform float uRadius = 2.0;
uniform float uFalloff = 1.0;
uniform int   uNumSteps = 4;
uniform int   uNumDirections = 2;
uniform float uIntensity = 1.0;

#define PI 3.14159265359

float hash12(vec2 p) {
	vec3 p3 = fract(vec3(p.xyx) * .1031);
	p3 += dot(p3, p3.yzx + 33.33);
	return fract((p3.x + p3.y) * p3.z);
}

vec3 getViewPos(vec2 uv) {
	float depth = texture(gDepth, uv).r;
	vec4  clipPos = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
	vec4  viewPos = invProjection * clipPos;
	return viewPos.xyz / viewPos.w;
}

vec3 reconstructNormal(vec2 uv, vec3 p) {
	vec2 texelSize = 1.0 / textureSize(gDepth, 0);
	vec3 left = getViewPos(uv + vec2(-texelSize.x, 0.0));
	vec3 right = getViewPos(uv + vec2(texelSize.x, 0.0));
	vec3 down = getViewPos(uv + vec2(0.0, -texelSize.y));
	vec3 up = getViewPos(uv + vec2(0.0, texelSize.y));

	vec3 dx = (abs(left.z - p.z) < abs(right.z - p.z)) ? (p - left) : (right - p);
	vec3 dy = (abs(down.z - p.z) < abs(up.z - p.z)) ? (p - down) : (up - p);

	return normalize(cross(dx, dy));
}

void main() {
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(outAO);
	if (pixel.x >= size.x || pixel.y >= size.y)
		return;

	vec2 uv = (vec2(pixel) + 0.5) / vec2(size);

	float depth = texture(gDepth, uv).r;
	if (depth >= 0.99999) {
		imageStore(outAO, pixel, vec4(1.0, 0.0, 0.0, 0.0));
		return;
	}

	vec3 viewPos = getViewPos(uv);
	vec3 viewNorm = reconstructNormal(uv, viewPos);
	vec3 viewDir = normalize(-viewPos);

	// GTAO Core
	float noise = hash12(uv + float(frameIndex) * 0.1234);
	float spatialOffset = hash12(uv * 1.5);

	float ao = 0.0;
	vec3  indirect = vec3(0.0);
	float stepSize = uRadius / float(uNumSteps);

	// Project radius to screen space accurately
	// We want the radius in UV space
	// Using projection matrix instead of view-projection for view-space radius
	float projScale = uProjection[0][0] * 0.5; // Scale from view to NDC
	float screenRadius = (uRadius * projScale) / -viewPos.z;

	for (int i = 0; i < uNumDirections; i++) {
		float angle = (float(i) + noise) * (PI / float(uNumDirections));
		vec2  dir = vec2(cos(angle), sin(angle));

		float h1 = -1.0;
		float h2 = -1.0;

		for (int j = 1; j <= uNumSteps; j++) {
			float dist = (float(j) - 1.0 + spatialOffset) * stepSize;

			// Sample in both directions
			vec2 offset = dir * dist * screenRadius;

			// Sample view space position at offset
			vec3 p1 = getViewPos(uv + offset);
			vec3 p2 = getViewPos(uv - offset);

			vec3 v1 = p1 - viewPos;
			vec3 v2 = p2 - viewPos;

			float d1 = length(v1);
			float d2 = length(v2);

			// Apply falloff
			float f1 = max(0.0, 1.0 - (d1 * d1) / (uRadius * uRadius * uFalloff));
			float f2 = max(0.0, 1.0 - (d2 * d2) / (uRadius * uRadius * uFalloff));

			if (d1 < uRadius) {
				h1 = max(h1, dot(normalize(v1), viewDir) * f1);

				// SSDI: simple radiance accumulation
				float weight = max(0.0, dot(normalize(v1), viewNorm)) * f1;
				indirect += texture(gColor, uv + offset).rgb * weight;
			}
			if (d2 < uRadius) {
				h2 = max(h2, dot(normalize(v2), viewDir) * f2);

				// SSDI: simple radiance accumulation
				float weight = max(0.0, dot(normalize(v2), viewNorm)) * f2;
				indirect += texture(gColor, uv - offset).rgb * weight;
			}
		}

		// Compute AO from horizon angles (simplified integral)
		ao += (acos(h1) + acos(h2)) / 2.0; // This is a bit more like GTAO
	}

	// Normalize AO and apply intensity
	float visibility = ao / (float(uNumDirections) * PI);
	ao = clamp(1.0 - (1.0 - visibility) * uIntensity, 0.0, 1.0);

	// Normalize Indirect light
	// Each direction has 2 samples, so total samples is 2 * uNumDirections * uNumSteps
	indirect /= (2.0 * float(uNumDirections) * float(uNumSteps));

	imageStore(outAO, pixel, vec4(ao, indirect.r, indirect.g, indirect.b));
}
