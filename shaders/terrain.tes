#version 420 core

layout(quads, fractional_odd_spacing, cw) in;

// Input from Tessellation Control Shader
in vec3 WorldPos_TC_out[];
in vec2 TexCoords_TC_out[];
in vec3 Normal_TC_out[];

// Output to Fragment Shader
out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

#include "visual_effects.glsl"

uniform mat4 view;
uniform mat4 projection;
uniform float uPhongAlpha = 1; // Controls the "puffiness" (0.0 = flat, 1.0 = full phong)

layout(std140) uniform Lighting {
	vec3  lightPos;
	vec3  viewPos; // Camera position
	vec3  lightColor;
	float time;
};

// Helper: Projects point q onto the plane defined by vertex v and normal n
// Formula: pi(q) = q - ((q - v) . n) * n
vec3 projectPointOnPlane(vec3 q, vec3 v, vec3 n) {
	return q - dot(q - v, n) * n;
}

// Helper: Bilinear interpolation for vec3
vec3 bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec2 uv) {
	vec3 bot = mix(v0, v1, uv.x);
	vec3 top = mix(v3, v2, uv.x);
	return mix(bot, top, uv.y);
}

void main() {
	// 1. Standard Linear Interpolation (What you already had)
	// This gives us the "Flat" position (q)
	vec2 uv = gl_TessCoord.xy;

	// Interpolate attributes
	vec2 texCoord1 = mix(TexCoords_TC_out[0], TexCoords_TC_out[1], uv.x);
	vec2 texCoord2 = mix(TexCoords_TC_out[3], TexCoords_TC_out[2], uv.x);
	TexCoords = mix(texCoord1, texCoord2, uv.y);

	vec3 pos1 = mix(WorldPos_TC_out[0], WorldPos_TC_out[1], uv.x);
	vec3 pos2 = mix(WorldPos_TC_out[3], WorldPos_TC_out[2], uv.x);
	vec3 q = mix(pos1, pos2, uv.y); // The flat position

	vec3 norm1 = mix(Normal_TC_out[0], Normal_TC_out[1], uv.x);
	vec3 norm2 = mix(Normal_TC_out[3], Normal_TC_out[2], uv.x);
	Normal = normalize(mix(norm1, norm2, uv.y));

	// 2. Phong Tessellation Logic
	// Project the flat point 'q' onto the tangent plane of each corner vertex
	vec3 p0 = projectPointOnPlane(q, WorldPos_TC_out[0], Normal_TC_out[0]);
	vec3 p1 = projectPointOnPlane(q, WorldPos_TC_out[1], Normal_TC_out[1]);
	vec3 p2 = projectPointOnPlane(q, WorldPos_TC_out[2], Normal_TC_out[2]);
	vec3 p3 = projectPointOnPlane(q, WorldPos_TC_out[3], Normal_TC_out[3]);

	// Interpolate these projected points to find the curved position
	// The paper uses barycentric interpolation for triangles[cite: 59],
	// but for quads, we use bilinear interpolation.
	vec3 posCurved = bilerp(p0, p1, p2, p3, uv);

	// 3. Mix flat and curved positions
	// This blend is often necessary because full Phong Tessellation can look too "ballooned"
	vec3 finalPos = mix(q, posCurved, uPhongAlpha);

	// 4. Distant Curl Effect
	if (distant_curl_enabled == 1 && distant_curl_strength > 0.0) {
		float distance = length(finalPos.xz - viewPos.xz);
		float fade_factor = smoothstep(
			distant_curl_fade_start,
			distant_curl_fade_end,
			distance
		);
		float curl = pow(distance, 2.0) * 0.00001 * distant_curl_strength * fade_factor;
		finalPos.y += curl;
	}

	FragPos = finalPos;

	// Final vertex position
	gl_Position = projection * view * vec4(FragPos, 1.0);
}
