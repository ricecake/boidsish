#version 420 core

layout(quads, fractional_odd_spacing, cw) in;

// Input from Tessellation Control Shader
in vec3       LocalPos_TC_out[];
in vec2       TexCoords_TC_out[];
flat in float TextureSlice_TC_out[];
flat in vec3  WorldOffset_TC_out[];
in float      perturbFactor_TC_out[];
in float      tessFactor_TC_out[];

// Output to Fragment Shader
out vec3  FragPos;
out vec3  Normal;
out vec2  TexCoords;
out float perturbFactor;
out float tessFactor;

// Heightmap texture array: R=height, GBA=normal
uniform sampler2DArray uHeightmap;
uniform int            uChunkSize;

uniform mat4  view;
uniform mat4  projection;
uniform float uPhongAlpha = 0.0;
uniform vec4  clipPlane;

#include "helpers/shockwave.glsl"
#include "helpers/terrain_noise.glsl"

// Sample heightmap to get world position and normal
void sampleHeightmap(vec2 uv, float slice, vec3 worldOffset, out vec3 worldPos, out vec3 normal) {
	vec4  data = texture(uHeightmap, vec3(uv, slice));
	float height = data.r;
	normal = normalize(data.gba);

	worldPos.x = worldOffset.x + uv.x * float(uChunkSize);
	worldPos.y = height;
	worldPos.z = worldOffset.z + uv.y * float(uChunkSize);
}

// Helper: Projects point q onto the plane defined by vertex v and normal n
vec3 projectPointOnPlane(vec3 q, vec3 v, vec3 n) {
	return q - dot(q - v, n) * n;
}

// Helper: Bilinear interpolation for vec3
vec3 bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec2 uv) {
	vec3 bot = mix(v0, v1, uv.x);
	vec3 top = mix(v3, v2, uv.x);
	return mix(bot, top, uv.y);
}

void main() {
	vec2 uv = gl_TessCoord.xy;

	// Get instance data (same for all corners)
	float slice = TextureSlice_TC_out[0];
	vec3  worldOffset = WorldOffset_TC_out[0];

	// Interpolate texture coordinates for this tessellated vertex
	vec2 texCoord1 = mix(TexCoords_TC_out[0], TexCoords_TC_out[1], uv.x);
	vec2 texCoord2 = mix(TexCoords_TC_out[3], TexCoords_TC_out[2], uv.x);
	TexCoords = mix(texCoord1, texCoord2, uv.y);

	// Sample heightmap at the interpolated UV to get world position and normal
	vec3 q, n;
	sampleHeightmap(TexCoords, slice, worldOffset, q, n);

	// For Phong tessellation, we need corner world positions and normals
	vec3 worldPos0, worldPos1, worldPos2, worldPos3;
	vec3 normal0, normal1, normal2, normal3;

	sampleHeightmap(TexCoords_TC_out[0], slice, worldOffset, worldPos0, normal0);
	sampleHeightmap(TexCoords_TC_out[1], slice, worldOffset, worldPos1, normal1);
	sampleHeightmap(TexCoords_TC_out[2], slice, worldOffset, worldPos2, normal2);
	sampleHeightmap(TexCoords_TC_out[3], slice, worldOffset, worldPos3, normal3);

	// Interpolate normals
	vec3 norm1 = mix(normal0, normal1, uv.x);
	vec3 norm2 = mix(normal3, normal2, uv.x);
	Normal = normalize(mix(norm1, norm2, uv.y));

	// Mix with raw heightmap normal based on smoothing toggle
	Normal = normalize(mix(n, Normal, uPhongAlpha));

	// Phong Tessellation: Project onto tangent planes
	vec3 p0 = projectPointOnPlane(q, worldPos0, normal0);
	vec3 p1 = projectPointOnPlane(q, worldPos1, normal1);
	vec3 p2 = projectPointOnPlane(q, worldPos2, normal2);
	vec3 p3 = projectPointOnPlane(q, worldPos3, normal3);

	// Bilinear interpolation of projected points
	vec3 posCurved = bilerp(p0, p1, p2, p3, uv);

	// Mix flat and curved positions
	FragPos = mix(q, posCurved, uPhongAlpha);

	// Apply shockwave ripple to terrain
	FragPos += getShockwaveDisplacement(FragPos, 0.0, false);

	// Clip plane for reflections
	gl_ClipDistance[0] = dot(FragPos, clipPlane.xyz) + clipPlane.w;

	// How much to perturb normal
	float perturbFactor1 = mix(perturbFactor_TC_out[0], perturbFactor_TC_out[1], uv.x);
	float perturbFactor2 = mix(perturbFactor_TC_out[3], perturbFactor_TC_out[2], uv.x);
	perturbFactor = mix(perturbFactor1, perturbFactor2, uv.y);

	float tessFactor1 = mix(tessFactor_TC_out[0], tessFactor_TC_out[1], uv.x);
	float tessFactor2 = mix(tessFactor_TC_out[3], tessFactor_TC_out[2], uv.x);
	tessFactor = mix(tessFactor1, tessFactor2, uv.y);

	// out float tessFactor;

	// Final vertex position
	gl_Position = projection * view * vec4(FragPos, 1.0);
}
