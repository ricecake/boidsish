#version 420 core

layout(quads, fractional_odd_spacing, cw) in;

// Input from Tessellation Control Shader
in vec3 WorldPos_TC_out[];
in vec2 TexCoords_TC_out[];
in vec3 Normal_TC_out[];

// Output to Fragment Shader
out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;

#include "visual_effects.glsl"

uniform mat4 view;
uniform mat4 projection;
uniform float uPhongAlpha = 1; // Controls the "puffiness" (0.0 = flat, 1.0 = full phong)

layout(std140) uniform Lighting {
	vec3  lightPos;
	vec3  viewPos; // Camera position
	vec3  lightColor;
	float time;
};

// Helper: Projects point q onto the plane defined by vertex v and normal n
// Formula: pi(q) = q - ((q - v) . n) * n
vec3 projectPointOnPlane(vec3 q, vec3 v, vec3 n) {
	return q - dot(q - v, n) * n;
}

// Helper: Bilinear interpolation for vec3
vec3 bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec2 uv) {
	vec3 bot = mix(v0, v1, uv.x);
	vec3 top = mix(v3, v2, uv.x);
	return mix(bot, top, uv.y);
}

// Helper: Creates a 3x3 rotation matrix from an axis and an angle in radians
mat3 rotationMatrix(vec3 axis, float angle) {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - s * axis.z,  oc * axis.z * axis.x + s * axis.y,
                oc * axis.x * axis.y + s * axis.z,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - s * axis.x,
                oc * axis.z * axis.x - s * axis.y,  oc * axis.y * axis.z + s * axis.x,  oc * axis.z * axis.z + c);
}

void main() {
	// 1. Standard Linear Interpolation (What you already had)
	// This gives us the "Flat" position (q)
	vec2 uv = gl_TessCoord.xy;

	// Interpolate attributes
	vec2 texCoord1 = mix(TexCoords_TC_out[0], TexCoords_TC_out[1], uv.x);
	vec2 texCoord2 = mix(TexCoords_TC_out[3], TexCoords_TC_out[2], uv.x);
	TexCoords = mix(texCoord1, texCoord2, uv.y);

	vec3 pos1 = mix(WorldPos_TC_out[0], WorldPos_TC_out[1], uv.x);
	vec3 pos2 = mix(WorldPos_TC_out[3], WorldPos_TC_out[2], uv.x);
	vec3 q = mix(pos1, pos2, uv.y); // The flat position

	vec3 norm1 = mix(Normal_TC_out[0], Normal_TC_out[1], uv.x);
	vec3 norm2 = mix(Normal_TC_out[3], Normal_TC_out[2], uv.x);
	Normal = normalize(mix(norm1, norm2, uv.y));

	// 2. Phong Tessellation Logic
	// Project the flat point 'q' onto the tangent plane of each corner vertex
	vec3 p0 = projectPointOnPlane(q, WorldPos_TC_out[0], Normal_TC_out[0]);
	vec3 p1 = projectPointOnPlane(q, WorldPos_TC_out[1], Normal_TC_out[1]);
	vec3 p2 = projectPointOnPlane(q, WorldPos_TC_out[2], Normal_TC_out[2]);
	vec3 p3 = projectPointOnPlane(q, WorldPos_TC_out[3], Normal_TC_out[3]);

	// Interpolate these projected points to find the curved position
	// The paper uses barycentric interpolation for triangles[cite: 59],
	// but for quads, we use bilinear interpolation.
	vec3 posCurved = bilerp(p0, p1, p2, p3, uv);

	// 3. Mix flat and curved positions
	// This blend is often necessary because full Phong Tessellation can look too "ballooned"
	vec3 finalPos = mix(q, posCurved, uPhongAlpha);

	// 4. Rotational Distant Curl Effect
	if (distant_curl_enabled == 1 && distant_curl_strength > 0.0) {
		float distance = length(finalPos.xz - viewPos.xz);
		float fade_factor = smoothstep(
			distant_curl_fade_start,
			distant_curl_fade_end,
			distance
		);

		// The angle of rotation increases with distance.
		// A negative angle curls "up" towards the viewer.
		float angle = -pow(distance, 1.5) * 0.0001 * distant_curl_strength * fade_factor;

		if (abs(angle) > 0.0001) {
			// The rotation axis is horizontal and perpendicular to the view direction vector
			vec3 viewDir = finalPos - viewPos;
			vec3 rotationAxis = normalize(cross(viewDir, vec3(0.0, 1.0, 0.0)));

			mat3 rotMat = rotationMatrix(rotationAxis, angle);

			// Rotate the vertex position around the camera's position
			finalPos = rotMat * (finalPos - viewPos) + viewPos;

			// The normal must also be rotated to ensure lighting is correct
			Normal = rotMat * Normal;
		}
	}

	FragPos = finalPos;

	// Final vertex position
	gl_Position = projection * view * vec4(FragPos, 1.0);
}